mads 2.1.6 build 65 (4 Jun 23)
Source: loaderFN.asm
     1 				     ;MICRO SPARTA DOS 4.7
     2 					 
     3 				; w wersji 4.7 dodac mo¿naby przechodzenie po kolejnych "ekranach" z lista plikow klawiszami
     4 				; "prawo"/"lewo" albo "gora"/"dol" ... ... ale to b.trudne
     5 				; ze wzgledu na mozliwosc roznej liczby plikow (stron) w zaleznosci czy wyswietlamy
     6 				; dlugie nazwy czy nie - nie da sie tego latwo zliczyc
     7
     8 				; dodany "Backspace" jako powrot do katalogu wyzej.
     9
    10 				; w wersji 4.6c zmieniony sposob rozpoznawania wielkosci sektora, dodane czytanie
    11 				; bloku PERCOM przy zmianie dysku...
    12 				; UWAGA! Bufor na pierwszy sektor ma dalej 128b, bezposrednio za nim jest bufor na sektor
    13 				; mapy, ktory moze byc zamazywany w chwili odczytu pierwszego sektora bez problemow.
    14
    15
    16 				; w wersji 4.6b poprawione dwa male bugi i dodane kulturalne wyjscie do DOS (Shift+Esc) ...
    17 				; ..... moznaby w tym momencie sprawdzac czy jest w ogole DOS w pamieci, bo bez DOS bedzie SelfTest
    18 					 
    19 				; w wersji 4.6 wyeliminowane chwilowe przelaczanie na domyslne kolory, ró¿ne poprawki procedur,
    20 				; ¿eby wiêcej gier siê uruchamia³o (zmiany w resecie i zmiennych systemowych)
    21 					 
    22 				; w wersji 4.5 obsluga napedow 9-15 pod Ctrl-litera gotowa (napedy 1-8 zdublowane pod klawiszami 1-8 i Ctrl-litera
    23 				; wyswietlanie "numeru" napedu w zaleznosci jak sie go wybierze (Dn: lub n: - cyfra lub litera)
    24 					 
    25 				; w wersji 4.4 (niepublikowanej) poprawiony blad. Nie moze byc dwa razy po sobie znacznika dziury w skompresowanej mapie
    26 				; czyli dziura max 127 sektorow a nie jak porzednio 254
    27 				; dodatkowo zapamietanie (na czas resetu przed czyszczeniem pamieci)
    28 				; stanu aktywnych urzadzen PBI i odtworzenie go po resecie (dzieki Drac030)
    29
    30 				; stan urzadzen na szynie PBI	 
    31 = 0247			PDVMASK = $0247
    32 					 
    33 				; nowa koncepcja zrobiona:
    34
    35 				; 1. wywaliæ turbo 'top-drive'
    36
    37 				; 2. przerobiæ loader i menu na obs³ugê sektorów dow. d³ugoœci
    38
    39 				; 3. przepisac czytanie tablicy sektorów indeksowych z loadera do menu:
    40 				;    a. w menu odczytywane s¹ wszystkie sektory tablicy indeksowej
    41 				;    b. budowana jest "skompresowana" tablica offsetów w stosunku do pierwszego sektora na nast. zasadzie:
    42 				;       mamy nast. znaczniki : (nowa koncepcja)
    43 				;       1xxxxxxx  -- (0xxxxxxx = ile sektorów omin¹æ) . Op³aci siê u¿ywaæ do max 255 sektorów do przeskoczenia.
    44 				;       0xxxxxxx  -- (0xxxxxxx = ile kolejnych sektorów wczytaæ)
    45 				;       00000000  -- nastêpne 2 bajty to numer kolejnego sektora do odczytania
    46 				;               
    47
    48 				; 4. nowa 'skompresowana' tablica indeksowa podwyzsza memlo
    49
    50 					 
    51 				     ;START ADDR = 1FFD
    52 				     ;END ADDR = 28C9
    53 				         ;.OPT noList
    54 				         
    55 				           icl 'lib/SYSEQU.ASM'
Source: SYSEQU.ASM
     1 				;    .PAGE "FTe SYSTEM EQUATES FOR ATARI"
     2 				;
     3 				;  FILE = #DN:SYSEQU.ASM
     4 				;
     5 				;
     6 				; I/O CONTROL BLOCK EQUATES
     7 				;
     8 				;SAVEPC = *      ; SAVE CURRENT ORG
     9 				;
    10
    11 = 0340			IOCB =  $0340   ;START OF SYSTEM IOCBS
    12 				;
    13 = 0340			ICHID = IOCB    ;DEVICE HANDLER IS (SET BY OS)
    14 = 0341			ICDNO = IOCB+1    ;DEVICE NUMBER (SET BY OS)
    15 = 0342			ICCOM = IOCB+2    ;I/O COMMAND
    16 = 0343			ICSTA = IOCB+3    ;I/O STATUS
    17 = 0344			ICBADR = IOCB+4   ;BUFFER ADDRESS
    18 = 0346			ICPUT = IOCB+6   ;DH PUT ROUTINE (ADR-1)
    19 = 0348			ICBLEN = IOCB+8   ;BUFFER LENGTH
    20 = 034A			ICAUX1 = IOCB+10   ;AUX 1
    21 = 034B			ICAUX2 = IOCB+11   ;AUX 2
    22 = 034C			ICAUX3 = IOCB+12   ;AUX 3
    23 = 034D			ICAUX4 = IOCB+13   ;AUX 4
    24 = 034E			ICAUX5 = IOCB+14   ;AUX 5
    25 = 034F			ICAUX6 = IOCB+15   ;AUX 6
    26 				;
    27 = 0010			IOCBLEN = 16 ;LENGTH OF ONE IOCB
    28 				;
    29 				; IOCB COMMAND VALUE EQUATES
    30 				;
    31 = 0003			COPN =  3       ;OPEN
    32 = 0007			CGBINR = 7      ;GET BINARY RECORD
    33 = 0005			CGTXTR = 5      ;GET TEXT RECORD
    34 = 000B			CPBINR = 11     ;PUT BINARY RECORD
    35 = 0009			CPTXTR = 9      ;PUT TEXT RECORD
    36 = 000C			CCLOSE = 12     ;CLOSE 
    37 = 000D			CSTAT = 13      ;GET STATUS
    38 				;
    39 				; DEVICE DEPENDENT COMMAND EQUATES FOR FILE MANAGER
    40 				;
    41 = 0020			CREN =  32      ;RENAME
    42 = 0021			CERA =  33      ;ERASE
    43 = 0023			CPRO =  35      ;PROTECT
    44 = 0024			CUNP =  36      ;UNPROTECT
    45 = 0025			CPOINT = 37     ;POINT
    46 = 0026			CNOTE = 38      ;NOTE
    47 				;
    48 				; AUX1 VALUES REQD FOR OPEN
    49 				;
    50 = 0004			OPIN =  4       ;OPEN INPUT
    51 = 0008			OPOUT = 8       ;OPEN OUTPUT
    52 = 000C			OPUPD = 12      ;OPEN UPDATE
    53 = 0009			OPAPND = 9      ;OPEN APPEND
    54 = 0006			OPDIR = 6       ;OPEN DIRECTORY
    55 				;
    56 				;    .PAGE 
    57 				;
    58 				;    EXECUTE FLAG DEFINES
    59 				;
    60 = 0080			EXCYES = $80    ; EXECUTE IN PROGRESS
    61 = 0040			EXCSCR = $40    ; ECHO EXCUTE INPUT TO SCREEN
    62 = 0010			EXCNEW = $10    ; EXECUTE START UP MODE
    63 = 0020			EXCSUP = $20    ; COLD START EXEC FLAG
    64 				;
    65 				; MISC ADDRESS EQUATES
    66 				;
    67 = 000A			CPALOC = $0A    ; POINTER TO CP/A
    68 = 0008			WARMST = $08    ; WAR, START (0=COLD)
    69 = 02E7			MEMLO = $02E7   ; AVAIL MEM (LOW) PTR
    70 = 02E5			MEMTOP = $02E5  ; AVAIL MEM (HIGH) PTR
    71 = 000E			APPMHI = $0E    ; UPPER LIMIT OF APPLICATION MEMORY
    72 = 02E2			INITADR = $02E2 ; ATARI LOAD/INIT ADR
    73 = 02E0			GOADR = $02E0   ; ATARI LOAD/GO ADR
    74 = BFFA			CARTLOC = $BFFA ; CARTRIDGE RUN LOCATION
    75 = E456			CIO =   $E456   ;CIO ENTRY ADR
    76 = 009B			EOL =   $9B     ; END OF LINE CHAR
    77 				;
    78 				;  CP/A FUNCTION AND VALUE DISPLACEMSNT
    79 				;     (INDIRECT THROUGH CPALOC)
    80 				;           IE. (CPALOC),Y
    81 				;
    82 = 0003			CPGNFN = 3      ; GET NEXT FILE NAME
    83 = 0007			CPDFDV = $07    ; DEFAULT DRIVE (3 BYTES)
    84 = 000A			CPBUFP = $0A    ; CMD BUFF NEXT CHAR POINTR (1 BYTE)
    85 = 000B			CPEXFL = $0B    ; EXECUTE FLAG
    86 = 000C			CPEXFN = $0C    ; EXECUTE FILE NAME (16 BYTES)
    87 = 001C			CPEXNP = $1C    ; EXECUTE NOTE/POINT VALUES
    88 = 0021			CPFNAM = $21    ; FILENAME BUFFER
    89 = 003D			RUNLOC = $3D    ; CP/A LOAD/RUN ADR
    90 = 003F			CPCMDB = $3F    ; COMMAND BUFFER (60 BYTES)
    91 = 00F3			CPCMDGO = $F3
    92 				;
    93 				;    *=  SAVEPC  ; RESTORE PC
    94 				;
    56
    57 				     
    58 = 000A			acktimeout = $a
    59 = 0002			readtimeout = 2
    60
    61
    62 = 0318			STACKP = $0318
    63 = 0042			CRITIC = $42
    64 = 02BD			DRETRY = $02BD
    65 = 030F			CASFLG = $030F
    66 = 029C			CRETRY = $029C
    67
    68
    69 = 0002			CASINI = $02
    70 				;WARMST = $08
    71 = 0009			BOOT   = $09
    72 = 000A			DOSVEC = $0a
    73 = 000C			DOSINI = $0c
    74 				;APPMHI = $0e
    75
    76 = 0010			IRQENS = $10
    77
    78
    79 				; zmienne procedury ladowania pliku (w miejscu zmiennych CIO - ktore sa nieuzywane)
    80
    81 				; adres komorki pamieci do ktorej zapisujemy kolejny ladowany bajt pliku
    82 = 0024			InBlockAddr = $24  ; word
    83 				; dlugosc ladowanego bloku odjeta od $10000 (zwiekszana osiaga ZERO po zaladowaniu bloku w calosci)
    84 = 0026			ToBlockEnd = $26  ; word
    85 = 0026			BlockLen= $26 ; word
    86 				; najmlodszy z trzech bajtow zliczajacych do konca pliku - patrz ToFileEndH
    87 = 0028			ToFileEndL = $28
    88 = 0028			BlockATemp = $28
    89 = 003D			CompressedMapPos = $3D ; pozycja w skompresowanej mapie pliku
    90
    91 = 0030			CheckSUM = $30
    92 = 0031			SecLenUS = $31
    93 = 0032			SecBuffer = $32
    94 = 0034			CRETRYZ = $34
    95 = 0035			TransmitError =$35
    96 = 0036			Looperka = $36
    97 = 0037			StackCopy = $37
    98
    99
   100 = 0058			SAVMSC = $58
   101 				; Adres bufora przechowywania Aktualnie obrabianego sektora zawierajacego
   102 				; katalog
   103 = 00CA			CurrentDirBuf = $CA
   104 				; adres konca tego bufora (2 bajty)
   105 = 00CC			CurrentDirBufEnd = $CC
   106 				; Adres (w buforze CurrentDirBuff, ale bezwzgledny) poczatku informacji
   107 				; o obrabianym pliku (skok co $17)
   108 = 00D0			CurrentFileInfoBuff = $D0
   109 				; Numer sektora ktory nalezy przeczytac - mapy sektorow aktualnego katalogu (2 bajty)
   110 = 00D2			DirMapSect = $D2
   111 				; Flaga ustawiana na 1 kiedy skoncza sie pliki do wyswietlenia w danym katalogu
   112 				; oznacza wyswietlanie ostatniej strony i jednoczesnie mowi o tym, ze po spacji
   113 				; ma byc wyswietlany katalog od poczatku
   114 = 00D6			LastFilesPageFlag = $D6
   115 				; Licznik nazw plikow wyswietlonych aktualnie na ekranie, po wyswietleniu strony
   116 				; zawiera liczbe widocznych na ekranie plikow (1 bajt)
   117 = 00D9			NamesOnScreen = $D9
   118 				; wskaznik pozycji w mapie sektorow czytanego katalogu (2 bajty) - nowa zmienna
   119 				; wczesniej byl 1 bajt w $D6
   120 = 00E2			InMapPointer = $E2
   121 				; zmienna tymczasowa na ZP (2 bajty)
   122 = 00E4			TempZP = $E4
   123
   124 = 020A			VSERIN = $020a
   125 = 02C5			COLPF1S = $02c5
   126 = 02C6			COLPF2S = $02c6
   127 = 02C8			COLBAKS = $02c8
   128
   129 = 0244			COLDST = $0244
   130 				;MEMTOP = $02e5
   131 				;MEMLO  = $02e7
   132
   133 = 02FC			KBCODES = $02fc
   134
   135 = 0300			DDEVIC = $0300
   136 = 0301			DUNIT  = $0301
   137 = 0302			DCOMND = $0302
   138 = 0304			DBUFA  = $0304
   139 = 0308			DBYT   = $0308
   140 = 030A			DAUX1  = $030a
   141 = 030B			DAUX2  = $030b
   142
   143 = 0342			ICCMD = $0342
   144 = 0344			ICBUFA = $0344
   145 				;ICBUFA+1 = $0345
   146 = 0348			ICBUFL = $0348
   147 				;ICBUFL+1 = $0349
   148 = 034A			ICAX1 = $034a
   149 = 034B			ICAX2 = $034b
   150
   151 = 03FA			GINTLK = $03FA ; 0 brak carta - potrzebne przy wylaczaniu Sparty X by oszukac OS ze nie bylo carta
   152
   153 = D204			AUDF3  = $d204
   154 = D206			AUDF4 = $d206
   155 = D207			AUDC4 = $d207
   156 = D208			AUDCTL = $d208
   157 = D20A			SKSTRES = $d20a
   158 = D20D			SEROUT = $D20d
   159 = D20D			SERIN = $D20d
   160 = D20E			IRQEN = $D20e
   161 = D20E			IRQST = $D20e
   162
   163
   164 = D20F			SKSTAT = $d20f
   165 = D20F			SKCTL = $d20f
   166
   167
   168 = D303			PBCTL  = $d303
   169 = D301			PORTB  = $d301
   170
   171 = D40B			VCOUNT = $D40B
   172
   173 = E456			JCIOMAIN   = $e456
   174 = E459			JSIOINT   = $e459
   175 = E471			JTESTROM = $e471
   176 = E474			JRESETWM = $e474
   177 = E477			JRESETCD = $e477
   178
   179 					org $1FFD
   180
   181 				; adres bufora na sektor wczytywanego pliku w oryginale $0800, ale moze wydluzyc sie procedura
   182 				; uwaga, ty juz odjety offset, wiec w procedurze nie odejmujemy!!!
   183 = 07D7			FileSecBuff = loader.FirstMapSectorNr   ; po przepisaniu
   184 = 07D7			TempMEMLO = loader.FirstMapSectorNr   ; Koniec procedury loader (poczatek bufora)
   185
   186 				START
   187 FFFF> 1FFD-2CE6> 4C 25 +      JMP   FirstRun           ;1FFD  4C 70 21
   188
   189 					 
   190 				; procedura ladujaca, ktora zostanie przepisana pod adres $0700 po wybraniu programu
   191 				; do wczytania !!!!!!
   192
   193 2000			movedproc 
   194 0700				.local loader, $0700
   195 				 
   196 				; dwa starsze bajty (bo to wielkosc 3 bajtowa) dlugosci pliku odjetej od $1000000
   197 				; dzieki czemu mozna stwierdzic osiagniecie konca pliku przez zwiekszanie tych
   198 				; bajtow (wraz z najmlodszym) i sprawdzanie czy osiagnieto ZERO
   199 0700			ToFileEndH
   200 0700 00 00		     .WO $0000
   201 0702			FileInit		; skok JSR pod adres inicjalizacji po (przed) kazdym nastepnym bloku binarnym
   202 0702 8A			     TXA
   203 0703 48			     PHA
   204 0704 A5 28		     LDA   ToFileEndL
   205 0706 48			     PHA
   206 0707 A5 3D			 LDA   CompressedMapPos
   207 0709 48				 PHA
   208 070A A5 3E			 LDA   CompressedMapPos+1
   209 070C 48				 PHA
   210 070D 20 93 07		     JSR   GoInitAddr
   211 0710 68				 PLA
   212 0711 85 3E			 STA   CompressedMapPos+1
   213 0713 68				 PLA
   214 0714 85 3D			 STA   CompressedMapPos
   215 0716 68			     PLA
   216 0717 85 28		     STA   ToFileEndL
   217 0719 68			     PLA
   218 071A AA			     TAX
   219 071B			FileNextBlock
   220 				     ; wczytanie kolejnego bloku binarnego
   221 071B 20 88 07		     JSR   FileGetBlockStart    ; pobranie dwoch bajtow (adres poczatku bloku)
   222 071E C0 88		     CPY  #$88  ; czy EOF
   223 0720 D0 03 4C A6 07	     jeq  EndOfFile
   224 0725 A5 24		     LDA   InBlockAddr
   225 0727 25 25		     AND   InBlockAddr+1
   226 0729 C9 FF		     CMP  #$FF							; jesli oba sa $FF to.....
   227 072B D0 03		     BNE   FileNoFFFFHead
   228 072D 20 88 07		     JSR   FileGetBlockStart 	; pobranie jeszcze raz  
   229 0730			FileNoFFFFHead
   230 0730 A5 24 85 28 A5 25 +      mwa InBlockAddr BlockATemp     ; zapamietanie adresu poczatkowego bloku (na chwile)
   231 0738 A9 26		     LDA #<BlockLen
   232 073A 85 24		     sta InBlockAddr
   233 073C A9 00		     lda #>BlockLen
   234 073E 85 25		     sta InBlockAddr+1
   235 0740 20 B0 07		     JSR GetFile2Bytes    ; pobranie dwoch bajtow - ; Pobranie adresu konca ladowanego bloku
   236 0743 C0 88		     CPY  #$88  ; czy EOF
   237 0745 F0 5F		     beq  EndOfFile
   238 				     ; wyliczenie d³ugoœci bloku programu binarnego
   239 0747 38			     sec
   240 0748 A5 26		     lda BlockLen
   241 074A E5 28		     sbc BlockATemp
   242 074C 85 26		     sta BlockLen
   243 074E A5 27		     lda BlockLen+1
   244 0750 E5 29		     sbc BlockATemp+1
   245 0752 85 27		     sta BlockLen+1
   246 0754 E6 26 D0 02 E6 27	     inw BlockLen
   247 075A A5 28 85 24 A5 29 +      mwa BlockATemp InBlockAddr     ; odtworzenie adresu poczatkowego bloku
   248 0762 38			     SEC
   249 0763			WhatIsIt
   250 0763 B0 0D		     BCS   FileNoFirstBlock 			; tu wstawiany jest raz (na poczatku) rozkaz LDA ($0D),Y
   251 														; ktory tylko wylacza skok !!!
   252 0765 CE 63 07		     DEC   WhatIsIt  			; Przywraca poprzednie BCS z poprzedniego wiersza!!
   253 0768 A5 24		     LDA   InBlockAddr          		; Czyli TO wykona sie tylko RAZ
   254 076A 8D E0 02		     STA   $02E0           				; Wpisujac adres pierwszego bloku do ard. startu
   255 076D A5 25		     LDA   InBlockAddr+1          		; na wypadek gdyby plik nie konczyl sie blokiem
   256 076F 8D E1 02		     STA   $02E1           				; z adresem startu (bywa i tak).
   257 0772			FileNoFirstBlock
   258 0772 A9 AF		     LDA  #<Jrts         		; do adresu inicjacji wpisanie adresu rozkazu RTS
   259 0774 8D E2 02		     STA   $02E2          				; bo po kazdym bloku odbywa sie tam skok
   260 0777 A9 07		     LDA  #>Jrts          	; jesli nie jest to blok z adresem inicjacji
   261 0779 8D E3 02		     STA   $02E3       					; to dzieki temu nic sie nie stanie
   262 				     
   263 077C			BlockReadLoop							;; petla odczytujaca z pliku blok binarny 
   264 077C 20 B8 07		     JSR  GetFileBytes
   265 077F C0 88		     CPY  #$88  ; czy EOF
   266 0781 F0 23		     beq  EndOfFile
   267 0783 F0 03 4C 02 07	     jne   FileInit        				; koniec bloku - skok pod adres inicjalizacji
   268 0788			FileGetBlockStart
   269 0788 A9 24		     LDA #<InBlockAddr
   270 078A 85 24		     sta InBlockAddr
   271 078C A9 00		     lda #>InBlockAddr
   272 078E 85 25		     sta InBlockAddr+1
   273 0790 4C B0 07		     JMP GetFile2Bytes    ; pobranie dwoch bajtow
   274 0793			GoInitAddr
   275 0793 6C E2 02		     JMP  ($02E2)
   276 0796			SioJMP
   277 0796 20 59 E4		     JSR   JSIOINT
   278 				  ;   BMI   ReadErrorLoop				; jesli blad odczytu sektora to czytamy ponownie
   279 0799 60			     RTS
   280 079A			blokDanychIO_Loader
   281 079A 31 01 52 40 D7 07 +     .BY $31,$01,$52,$40,<FileSecBuff,>FileSecBuff,$0A,$00,$80,$00
   282 				; Dlugosc sektora to dwa ostatnie bajty bloku danych ($0080 lub $0100)
   283 = 07A2			SecLen = blokDanychIO_Loader+8 ; SecLen wskazuje na komórki do wpisania d³ugoœci sektora przed przepisaniem procki na stronê $0700
   284 07A4			SectorNumber
   285 07A4 00 00		    .WO $0000
   286 07A6			EndOfFile								; to wykona sie przy nieoczekiwanym (i oczekiwanym) koncu pliku
   287 07A6 A9 E4		     LDA  #>(JRESETWM-1)     ; cieply start (RESET) zamiast SelfTestu
   288 07A8 48			     PHA
   289 07A9 A9 73		     LDA  #<(JRESETWM-1)
   290 07AB 48			     PHA
   291 				;WaitLine0
   292 				;     LDA  VCOUNT
   293 				;	 bne WaitLine0
   294 07AC 6C E0 02		     JMP  ($02E0)
   295 07AF			Jrts
   296 07AF 60			     RTS
   297 07B0			GetFile2Bytes
   298 07B0 A9 02 85 26 A9 00 +     mwa #2 BlockLen
   299 07B8			GetFileBytes
   300 07B8 A2 10		      LDX #16 ; kanal 1
   301 07BA A9 07		      LDA #CGBINR ; rozkaz BGET
   302 07BC 9D 42 03		      STA ICCOM,X ; COMMAND
   303 07BF A5 24		      LDA InBlockAddr
   304 07C1 9D 44 03		      STA ICBUFA,x
   305 07C4 A5 25		      LDA InBlockAddr+1
   306 07C6 9D 45 03		      STA ICBUFA+1,x
   307 07C9 A5 26		      LDA BlockLen
   308 07CB 9D 48 03		      STA ICBUFL,x
   309 07CE A5 27		      LDA BlockLen+1
   310 07D0 9D 49 03		      STA ICBUFL+1,x
   311 07D3 4C 56 E4		      JMP CIO
   312
   313 				; starszy bajt licznika pozycji bajtu w sektorze - mlodszy jest caly czas w X
   314 				; potrzebny do obslugi sektorow wiekszych od 256b
   315 07D6			InSectorCountH
   316 07D6 00			    .BY $00
   317 				; koniec czesci glownejprocedury ladowania pliku przepisywanej pod $0700
   318 				; tu zaczyna sie (takze przepisywana) procedura wykonujaca sie tylko raz
   319 				; w tym miejscu potem bedzie bufor
   320 				; Tutaj wpisywany jest przez menu loadera numer pierwszego sektora
   321 				; mapy pliku do wczytania, potrzebny tylko na starcie ladowania
   322 07D7			zzzzzz  ; dla wygody - ta etykieta powinna miec $2100 jesli procedura ja poprzedzajaca miesci sie na stronie
   323 07D7			FirstMapSectorNr
   324 07D7 00 00		     .WO $0000
   325 07D9			LoadStart
   326 					 ; na poczatek czyszczenie pamieci od MEMLO do MEMTOP
   327 07D9 AC E7 02		     LDY   MEMLO
   328 07DC AD E8 02		     LDA   MEMLO+1
   329 07DF 8D E6 07		     STA   InMemClearLoop+2
   330 07E2			OutMemClearLoop
   331 07E2 A9 00		     LDA  #$00
   332 07E4			InMemClearLoop
   333 07E4 99 00 09		     STA   $0900,Y
   334 07E7 C8			     INY
   335 07E8 D0 FA		     BNE   InMemClearLoop
   336 07EA EE E6 07		     INC   InMemClearLoop+2
   337 07ED AD E6 07		     LDA   InMemClearLoop+2
   338 07F0 CD E6 02		     CMP   MEMTOP+1
   339 07F3 90 ED		     BCC   OutMemClearLoop
   340 07F5 AD E6 02		     LDA   MEMTOP+1
   341 07F8 8D 02 08		     STA   LastMemPageClear+2
   342 07FB AC E5 02		     LDY   MEMTOP
   343 07FE A9 00		     LDA  #$00
   344 0800			LastMemPageClear
   345 0800 99 00 80		     STA   $8000,Y
   346 0803 88			     DEY
   347 0804 C0 FF		     CPY  #$FF
   348 0806 D0 F8		     BNE   LastMemPageClear
   349 					 ; wyczyszczona, wiec ....
   350 0808 AD 21 08		     LDA   tempToFileEndL
   351 080B 85 28		     STA   ToFileEndL
   352 080D A9 FF		     LDA  #$FF
   353 080F 8D FC 02		     STA   KBCODES
   354 0812 EE 63 07		     INC   WhatIsIt	; zmiana BCS omijajacego procedure na LDA (adres pierwszego bloku do STARTADR)
   355 0815 AE A2 07		     LDX   SecLen		; dlugosc sektora do X, czyli wymuszenie przeczytania nastepnego sektora
   356 0818 AD A3 07			 LDA   Seclen+1			; --
   357 081B 8D D6 07			 STA   InSectorCountH		; --   obsluga sektorow ponad 256b
   358 				     ;jmp *
   359 081E 4C 1B 07		     JMP   FileNextBlock
   360 				; tymczasowe przechowanie najmlodszego bajtu licznika do konca pliku
   361 				; sluzy do przepisania tego bajtu z glownego programu do zmiennej loadera
   362 0821			tempToFileEndL
   363 0821 00			     .BY $00
   364 				    .endl
   365 2122			JAkieTurbo
   366 2122			USmode
   367 2122 01				 .BY $01     ; 0 - brak turbo   1 - Ultra Speed
   368 2123			QMEG
   369 2123 01			     .BY $01    ;1 - brak QMEGa     0 - jest QMEG
   370 2124			BootDrive
   371 2124 00			     .BY $00    ;Numer stacji dysków z której sie BOOT robi
   372 2125			BootShift
   373 2125 01			     .BY $01	; stan Shift w czasie bootowania (przyda sie jednak)  1 - bez shift  0 - Shift wcisniety
   374 2126			FolderTurbo
   375 2126 01				 .BY $01	; 00 wy³¹cza turbo 01 - zostawia tak jak jest - ty ma sie wpisywac znacznik turbo dla katalogu z MSDOS.DAT
   376 2127			NewColors
   377 2127 00				 .BY $00   ; 00 oznacza ze nie zaladowano kolorow z pliku DAT i trzeba ustawic standardowe - inna wartosc zaladowano
   378 				; Zamiana 4 mlodszych bitow z A na liczbe Hex w Ascii (tez w A)
   379 2128			bin2AsciiHex
   380 2128 29 0F		     AND  #$0F 
   381 212A 09 30		     ORA  #$30 
   382 212C C9 3A		     CMP  #$3A
   383 212E 90 03		     BCC   labelka 
   384 2130 18			     CLC
   385 2131 69 07		     ADC  #$07
   386 2133			labelka
   387 2133 60			     RTS 
   388 2134			Edriver
   389 2134 45 3A 9B		     .BY "E:",$9b      
   390 2137			EditorOpen
   391 				     ; otwarcie ekranu !!!
   392 2137 A2 00		     LDX  #$00             ; kanal nr 0
   393 2139 20 F6 2A		     JSR   CloseX           ; najpierw Zamkniecie Ekranu
   394 213C 30 55		     BMI   ErrorDisplay
   395 213E A2 00		     LDX  #$00             ; kanal nr 0
   396 2140 A9 03		     LDA  #$03 
   397 2142 9D 42 03		     STA   ICCMD,X 
   398 2145 A9 0C		     LDA  #$0C 
   399 2147 9D 4A 03		     STA   ICAX1,X
   400 214A 9D 48 03		     STA   ICBUFL,X
   401 214D A9 00		     LDA  #$00 
   402 214F 9D 4B 03		     STA   ICAX2,X
   403 2152 9D 49 03		     STA   ICBUFL+1,X
   404 2155 A9 34		     LDA  #<Edriver
   405 2157 9D 44 03		     STA   ICBUFA,X
   406 215A A9 21		     LDA  #>Edriver
   407 215C 9D 45 03		     STA   ICBUFA+1,X
   408 215F 20 56 E4		     JSR   JCIOMAIN            ; Otwarcie "E:" w trybie Gr.0
   409 2162 30 2F		     BMI   ErrorDisplay
   410 2164 60			     RTS
   411 					 
   412 2165			mainprog
   413 2165 AD 23 21		     LDA   QMEG       ; jesli jest QMEG to wylacza sie tryb US
   414 2168 2D 25 21			 AND   BootShift  ; i jak byl Shift w czasie bootowania tez sie wylacza
   415 216B 8D 22 21		     STA   USmode           
   416 216E F0 1E		     BEQ   NoUSSpeed
   417 				     ; Pytanie stacji o predkosc transmisji Happy/US-Doubler
   418 2170 A0 BC		     ldy  #<blokDanychIO_GetUSSpeed    
   419 2172 A2 28		     ldx  #>blokDanychIO_GetUSSpeed
   420 2174 20 E2 2A		     jsr   Table2DCB
   421 2177 20 59 E4		     jsr   JSIOINT             ; wysylamy "?"
   422 217A 10 07		     bpl   USSpeed
   423 217C A9 00		     lda   #0		; blad odczytu wiec nie ma USspeed - zerujemy wiec flage
   424 217E 8D 22 21			 sta   USmode
   425 2181 F0 0B			 beq   NoUSSpeed
   426 2183			USSpeed
   427 2183 A0 02			 LDY #$2
   428 2185			USstatprint
   429 2185 B9 1E 2C			 LDA ONtext,y
   430 2188 99 F7 22			 STA USstatus,y
   431 218B 88				 DEY
   432 218C 10 F7			 bpl USstatprint
   433
   434 218E			NoUSSpeed
   435 218E 4C D4 21		     JMP   ReadMainDir        
   436 2191			Error148
   437 2191 A0 94		     LDY  #$94             ; kod bledu do Y
   438 				     ; wyswietlenie komunikatu o bledzie - kod bledu w Y
   439 2193			ErrorDisplay
   440 2193 98			     TYA
   441 2194 48			     PHA
   442 2195 20 F4 2A		     JSR   Close1
   443 2198 68			     PLA 
   444 2199 48			     PHA
   445 219A 4A			     LSR
   446 219B 4A			     LSR 
   447 219C 4A			     LSR
   448 219D 4A			     LSR
   449 219E 20 28 21		     JSR   bin2AsciiHex  ; 4 starsze bity na HEX
   450 21A1 8D BA 21		     STA   ErrorNumHex
   451 21A4 68			     PLA 
   452 21A5 20 28 21		     JSR   bin2AsciiHex  ; 4 mlodsze bity na HEX
   453 21A8 8D BB 21		     STA   ErrorNumHex+1 
   454 21AB 20 47 2A		     JSR   PrintXY
   455 21AE 00 00		     .BY $00,$00  
   456 21B0 7D			     .BY $7d              ; kod czyszczenia ekranu
   457 21B1 45 52 52 4F 52 20 +      .BY "ERROR - $"
   458 21BA			ErrorNumHex
   459 21BA 30 30 00		     .BY "00",$00
   460 				     ; czekamy na dowolny klawisz
   461 21BD A9 FF		     LDA  #$FF
   462 21BF 8D FC 02		     STA   KBCODES 
   463 21C2			WaitKloop
   464 21C2 AE FC 02		     LDX   KBCODES
   465 21C5 E8			     INX 
   466 21C6 F0 FA		     BEQ   WaitKloop 
   467 21C8 8D FC 02		     STA   KBCODES    ; w A jest $FF
   468 				     ; ------------------
   469 				     ; na wypadek wybrania nieistniejacej stacji
   470 				     ; po bledzie przechodzimy na te z ktorej sie ladowalismy
   471 21CB AD 24 21		     LDA BootDrive
   472 					 ;LDA #1
   473 21CE 20 99 2B		     JSR SeTDriveNR
   474 				     ; -----------------
   475 21D1 4C 65 21		     JMP   mainprog     ; i odpalamy program od nowa
   476 21D4			ReadMainDir
   477 21D4 20 C1 29		     JSR  ReadPERCOM
   478 21D7 A2 2D		     LDX  #>FirstSectorBuff
   479 21D9 A0 00		     LDY  #<FirstSectorBuff
   480 21DB 20 F6 29		     JSR   ReadFirstSect
   481 				; Sprawdzenie wersji DOSa pod ktora formatowany byl dysk
   482 21DE AD 20 2D		     LDA   FirstSectorBuff+$20
   483 21E1 C9 11		     CMP  #$11            ; Sparta DOS 1.1
   484 21E3 F0 08		     BEQ   SpartaDisk
   485 21E5 C9 20		     CMP  #$20            ; Sparta DOS 2.x 3.x Sparta DOS X 4.1x/4.2x
   486 21E7 F0 04		     BEQ	SpartaDisk
   487 21E9 C9 21			 CMP  #$21			   ; Nowy format Sparta DOS X >= 4.39 (moga byc sektory wieksze niz 256b)
   488 21EB D0 A4		     BNE   Error148       ; Nieobslugiwany format dyskietki
   489 21ED			SpartaDisk
   490 21ED A2 00		     LDX  #$00 
   491 				; pobranie dlugosci sektora ($00 lub $80) - poprawione dla wiekszych niz 256
   492 21EF AD 1F 2D		     LDA   FirstSectorBuff+$1F
   493 21F2 30 04		     BMI   Sektor128b
   494 21F4 AA				 TAX
   495 21F5 A9 00			 LDA  #$00
   496 21F7 E8			     INX                   ; i wyliczenie starszego bajtu
   497 21F8			Sektor128b
   498 21F8 8D A2 20		     STA   .adr loader.SecLen	; przed przepisaniem
   499 21FB 8E A3 20		     STX   .adr loader.SecLen+1	; przed przepisaniem
   500 					 ; pokazanie na ekranie
   501 21FE BD 1B 2C			 LDA   DensityCodes,X
   502 2201 8D D3 22			 STA   DensityDisplay
   503 				; pobranie numeru pierwszego sektora mapy sektorow glownego katalogu
   504 2204 AC 09 2D		     LDY   FirstSectorBuff+$09
   505 2207 AE 0A 2D		     LDX   FirstSectorBuff+$0A
   506 				; odczyt katalogu, ktorego mapa zaczyna sie w sektorze y*256+x
   507 220A			ReadDIR
   508 				; ustawienie znacznika wlaczenia Turbo dla katalogu
   509 220A A9 01			 LDA  #$01
   510 220C 8D 26 21			 STA   FolderTurbo
   511 220F 84 D2		     STY   DirMapSect
   512 2211 86 D3		     STX   DirMapSect+1
   513 2213 A9 2F		     LDA  #>DirSectorBuff
   514 2215 85 D1		     STA   CurrentFileInfoBuff+1
   515 2217 85 CB		     STA   CurrentDirBuf+1
   516 2219 A9 80		     LDA  #<DirSectorBuff
   517 221B 85 D0		     STA   CurrentFileInfoBuff
   518 221D 85 CA		     STA   CurrentDirBuf
   519 221F A9 00		     LDA  #$00 
   520 2221 8D 27 21			 STA   NewColors       ; wyzerowanie kolorow tak zeby jak nie bedzie ich w DAT ustawily sie standardowe (akurat mamy 0 w A)
   521 2224 85 D4		     STA   $D4
   522 2226 85 D5		     STA   $D5
   523 2228 A9 17		     LDA  #$17
   524 222A 20 CB 28		     JSR   label39
   525 222D A5 D0		     LDA   CurrentFileInfoBuff
   526 222F 85 CC		     STA   CurrentDirBufEnd
   527 2231 A5 D1		     LDA   CurrentFileInfoBuff+1
   528 2233 85 CD		     STA   CurrentDirBufEnd+1
   529 2235 A9 00		     LDA  #$00
   530 2237 85 D7		     STA   $D7
   531 2239 85 D8		     STA   $D8
   532 223B A5 CA		     LDA   CurrentDirBuf
   533 223D 85 D0		     STA   CurrentFileInfoBuff
   534 223F A5 CB		     LDA   CurrentDirBuf+1
   535 2241 85 D1		     STA   CurrentFileInfoBuff+1
   536 2243			label46
   537 2243 A5 D1		     LDA   CurrentFileInfoBuff+1
   538 2245 C5 CD		     CMP   CurrentDirBufEnd+1
   539 2247 90 08		     BCC   label40
   540 2249 D0 71		     BNE   ToStartOfDir
   541 224B A5 D0		     LDA   CurrentFileInfoBuff
   542 224D C5 CC		     CMP   CurrentDirBufEnd
   543 224F B0 6B		     BCS   ToStartOfDir
   544 2251			label40
   545 2251 A0 00		     LDY  #$00
   546 2253 B1 D0		     LDA  (CurrentFileInfoBuff),Y
   547 2255 29 38		     AND  #$38
   548 2257 C9 08		     CMP  #$08
   549 2259 D0 1C		     BNE   label42
   550 225B A0 10		     LDY  #$10
   551 225D A2 0A		     LDX  #$0A
   552 225F			label43
   553 225F B1 D0		     LDA  (CurrentFileInfoBuff),Y
   554 2261 DD 6C 22		     CMP   ProgName,X
   555 2264 D0 11		     BNE   label42
   556 2266 88			     DEY
   557 2267 CA			     DEX
   558 2268 10 F5		     BPL   label43
   559 226A 30 19		     BMI   DATfileFound
   560 226C			ProgName
   561 226C 4D 53 44 4F 53 20 +      .BY "MSDOS   DAT"
   562 2277			label42
   563 2277 A5 D0		     LDA   CurrentFileInfoBuff
   564 2279 18			     CLC
   565 227A 69 17		     ADC  #$17
   566 227C 85 D0		     STA   CurrentFileInfoBuff
   567 227E 90 02		     BCC   label45
   568 2280 E6 D1		     INC   CurrentFileInfoBuff+1
   569 2282			label45
   570 2282 4C 43 22		     JMP   label46
   571 				; znaleziono plik z dlugimi nazwami
   572 2285			DATfileFound
   573 				     ; numer pierwszego sektora mapy sektorow pliku MSDOS.DAT przepisujemy do
   574 					 ; wskaznika aktualnego sektora mapy pliku/katalogu. Dzieki temu przy skoku do procedury czytania
   575 					 ; sektora mapy, przeczyta sie wlasnie ten pierwszy
   576 2285 A0 01		     LDY  #$01
   577 2287 B1 D0		     LDA  (CurrentFileInfoBuff),Y
   578 2289 85 D2		     STA   DirMapSect 
   579 228B C8			     INY
   580 228C B1 D0		     LDA  (CurrentFileInfoBuff),Y 
   581 228E 85 D3		     STA   DirMapSect+1
   582 2290 C8			     INY
   583 2291 B1 D0		     LDA  (CurrentFileInfoBuff),Y
   584 2293 85 D4		     STA   $D4
   585 2295 C8			     INY 
   586 2296 B1 D0		     LDA  (CurrentFileInfoBuff),Y 
   587 2298 85 D5		     STA   $D5
   588 229A C8			     INY
   589 229B B1 D0		     LDA  (CurrentFileInfoBuff),Y
   590 229D F0 06		     BEQ   label47
   591 229F A9 FF		     LDA  #$FF
   592 22A1 85 D4		     STA   $D4 
   593 22A3 85 D5		     STA   $D5
   594 22A5			label47
   595 22A5 A5 CC		     LDA   CurrentDirBufEnd
   596 22A7 85 D0		     STA   CurrentFileInfoBuff
   597 22A9 A5 CD		     LDA   CurrentDirBufEnd+1
   598 22AB 85 D1		     STA   CurrentFileInfoBuff+1
   599 22AD A9 2E		     LDA  #$2E
   600 22AF 20 CB 28		     JSR   label39
   601 22B2 A5 D0		     LDA   CurrentFileInfoBuff
   602 22B4 85 CE		     STA   $CE
   603 22B6 A5 D1		     LDA   CurrentFileInfoBuff+1
   604 22B8 85 CF		     STA   $CF
   605 22BA E6 D8		     INC   $D8
   606 				; ustawienie wskaznikow dla listy wyswietlanych plikow na poczatek katalogu
   607 22BC			ToStartOfDir
   608 22BC A9 00			 LDA  #$00
   609 22BE 85 D6		     STA   LastFilesPageFlag
   610 22C0 A5 CA		     LDA   CurrentDirBuf
   611 22C2 18			     CLC
   612 22C3 69 17		     ADC  #$17
   613 22C5 85 D0		     STA   CurrentFileInfoBuff
   614 22C7 A5 CB		     LDA   CurrentDirBuf+1
   615 22C9 69 00		     ADC  #$00
   616 22CB 85 D1		     STA   CurrentFileInfoBuff+1
   617 22CD			StatusBarPrint
   618 22CD 20 47 2A		     JSR   PrintXY
   619 22D0 00 00		     .BY $00,$00
   620 22D2 7D			     .BY $7d
   621 22D3			DensityDisplay
   622 22D3 A0 C4		     .BY +$80," D"
   623 22D5			DriveDisp1        ;                               "
   624 22D5 C1 BA A0 CD D3 C4 +      .BY +$80,"A: MSDOS 4.7  QMEG:"
   625 22E8			QMEGstatus
   626 22E8 CF C6 C6 AF C2 C1 + 	 .BY +$80,"OFF/BAS:"
   627 22F0			BASstatus
   628 22F0 CF C6 C6 AF D5 D3 + 	 .BY +$80,"OFF/US:"
   629 22F7			USstatus
   630 22F7 CF C6 C6 A0			 .BY +$80,"OFF "  ; w inversie
   631 22FB 00			     .BY $00
   632 				; Nowa (minus pierwsza ;) linijka opisu na dole
   633 22FC 20 47 2A			 JSR PrintXY
   634 22FF 11 15			 .BY $11,$15
   635 2301 B1				 .BY +$80,"1"
   636 2302 2D				 .BY "-"
   637 2303 B8				 .BY +$80,"8"
   638 2304 20 6F 72 20			 .BY " or "
   639 2308 E3 F4 F2 EC		     .BY +$80,"ctrl"
   640 230C 2B				 .BY "+"
   641 230D C1 AE AE CF			 .BY +$80,"A..O"
   642 2311 20 44 72 69 76 65		 .BY " Drive"
   643 2317 00				 .BY $00
   644 				; Pierwsza linijka opisu na dole strony
   645 2318 20 47 2A		     JSR   PrintXY
   646 231B 01 16		     .BY $01,$16
   647 231D D3 D0 C1 C3 C5	     .BY +$80,"SPACE"
   648 2322 3A 43 6F 6E 74 69 +      .BY ":Continue  "
   649 232D D3 C8 C9 C6 D4	     .BY +$80,"SHIFT"
   650 2332 2B 2E 2E 2E 4E 6F +      .BY "+...No High Speed"
   651 2343 00			     .BY $00 
   652 				; Druga linijka opisu na dole strony
   653 2344 20 47 2A		     JSR   PrintXY
   654 2347 02 17		     .BY $02,$17
   655 2349 C5 D3 C3		     .BY +$80,"ESC"
   656 234C 3A 41 6C 6C 20 66 +      .BY ":All files  "
   657 2358 BE			     .BY +$80,">"
   658 2359 3A 4D 61 69 6E 20 +      .BY ":Main Dir.  "
   659 2365 BC			     .BY +$80,"<"
   660 2366 3A 55 50 2D 44 49 +      .BY ":UP-DIR."
   661 236E 00			     .BY $00
   662 236F A9 00		     LDA  #$00
   663 2371 85 D9		     STA   NamesOnScreen
   664 2373			label68
   665 2373 A5 D1		     LDA   CurrentFileInfoBuff+1
   666 2375 C5 CD		     CMP   CurrentDirBufEnd+1
   667 2377 90 08		     BCC   NoLastFileInDir
   668 2379 D0 55		     BNE   LastFilesPageJump
   669 237B A5 D0		     LDA   CurrentFileInfoBuff
   670 237D C5 CC		     CMP   CurrentDirBufEnd
   671 237F B0 4F		     BCS   LastFilesPageJump
   672 2381			NoLastFileInDir
   673 2381 A0 00		     LDY  #$00
   674 2383 B1 D0		     LDA  (CurrentFileInfoBuff),Y 
   675 2385 F0 49		     BEQ   LastFilesPageJump
   676 2387 A2 22		     LDX  #$22
   677 2389 A9 20		     LDA  #$20    ; spacja
   678 238B			label50
   679 238B 9D 3C 24		     STA   GameName,X
   680 238E CA			     DEX 
   681 238F 10 FA		     BPL   label50
   682 2391 A0 10		     LDY  #$10
   683 2393 A2 0A		     LDX  #$0A
   684 2395			label51
   685 2395 B1 D0		     LDA  (CurrentFileInfoBuff),Y
   686 2397 9D 3C 24		     STA   GameName,X
   687 239A 88			     DEY
   688 239B CA			     DEX
   689 239C 10 F7		     BPL   label51
   690 239E A5 D9		     LDA   NamesOnScreen
   691 23A0 18			     CLC
   692 23A1 69 41		     ADC  #$41   ; literka "A"
   693 23A3 8D 39 24		     STA   GameKeySymbol
   694 23A6 A5 D8		     LDA   $D8
   695 23A8 D0 2C		     BNE   label52
   696 23AA A0 00		     LDY  #$00
   697 				  ; status sprawdzanego pliku
   698 23AC B1 D0		     LDA  (CurrentFileInfoBuff),Y 
   699 23AE 29 19		     AND  #$19
   700 23B0 C9 09		     CMP  #$09
   701 				  ; sprawdzamy czy Nie skasowany, zabezpieczony i "w uzyciu"
   702 23B2 F0 08		     BEQ   label53
   703 23B4 A6 D7		     LDX   $D7
   704 23B6 F0 1B		     BEQ   label54
   705 23B8 C9 08		     CMP  #$08
   706 23BA D0 17		     BNE   label54
   707 23BC			label53
   708 				  ; jeszcze raz status sprawdzanego pliku
   709 23BC B1 D0		     LDA  (CurrentFileInfoBuff),Y
   710 23BE 29 20		     AND  #$20
   711 				  ; sprawdzenie czy to podkatalog jesli nie 'label55' (czyli plik)
   712 23C0 F0 0B		     BEQ   label55
   713 				  ; obsluga wyswietlenia nazwy podlatalogu (dopisanie "<SUB-DIR>")
   714 23C2 A2 08		     LDX  #$08
   715 23C4			label56
   716 23C4 BD 4B 25		     LDA   SubDirText,X
   717 23C7 8D 48 24		     STA   GameName+12
   718 23CA CA			     DEX
   719 23CB 10 F7		     BPL   label56
   720 23CD			label55
   721 23CD 4C 2C 24		     JMP   GameNamePrint
   722 23D0			LastFilesPageJump
   723 23D0 4C D4 24		     JMP   LastFilesPage
   724 23D3			label54
   725 23D3 4C 84 24		     JMP   label59
   726 23D6			label52
   727 23D6 A0 00		     LDY  #$00
   728 23D8 B1 D0		     LDA  (CurrentFileInfoBuff),Y
   729 23DA 29 18		     AND  #$18
   730 23DC C9 08		     CMP  #$08
   731 23DE D0 F3		     BNE   label54
   732 23E0 A5 CC		     LDA   CurrentDirBufEnd
   733 23E2 85 D4		     STA   $D4
   734 23E4 A5 CD		     LDA   CurrentDirBufEnd+1
   735 23E6 85 D5		     STA   $D5
   736 23E8			label65
   737 23E8 A5 D5		     LDA   $D5
   738 23EA C5 CF		     CMP   $CF
   739 23EC 90 08		     BCC   label60
   740 23EE D0 E3		     BNE   label54 
   741 23F0 A5 D4		     LDA   $D4
   742 23F2 C5 CE		     CMP   $CE
   743 23F4 B0 DD		     BCS   label54
   744 				; tu trzebaby sprawdzic * - tyle ze sprawdzaloby sie to przy szukaniu kazdej nazwy
   745 23F6			label60
   746 23F6 A0 00		     LDY #$00
   747 23F8 B1 D4			 LDA ($D4),Y
   748 23FA C9 2A			 CMP #'*'
   749 23FC D0 06			 BNE CompareNames
   750 23FE 8D 27 21			 STA NewColors
   751 2401 20 5F 2B			 JSR Asteriks
   752 2404			CompareNames
   753 				; Porownanie nazwy pliku do wyswietlenia z nazwa z MSDOS.DAT
   754 2404 A0 0A		     LDY  #$0A      ; 8+3 znaki
   755 2406			Checking62
   756 2406 B1 D4		     LDA  ($D4),Y 
   757 2408 D9 3C 24		     CMP   GameName,Y 
   758 240B D0 11		     BNE   CheckNextName  ; jesli to nie ta nazwa sprawdzamy nastepna z bufora dlugich nazw
   759 240D 88			     DEY
   760 240E 10 F6		     BPL   Checking62
   761 				; Wpisanie nazwy "ekranowej" zamiast nazwy pliku
   762 2410 A0 0B		     LDY  #$0B     ; przesuniecie o 11 bajtow zeby ominac nazwe DOSowa pliku
   763 2412			ReplacingName
   764 2412 B1 D4		     LDA  ($D4),Y 
   765 2414 99 31 24		     STA   GameName-$0B,Y  ; nadpisujemy nazwe pliku w buforze wyswietlania
   766 2417 C8			     INY 
   767 2418 C0 2E		     CPY  #$2E
   768 241A 90 F6		     BCC   ReplacingName
   769 241C B0 0E		     BCS   GameNamePrint
   770 241E			CheckNextName
   771 241E A5 D4		     LDA   $D4 
   772 2420 18			     CLC
   773 2421 69 2E		     ADC  #$2E
   774 2423 85 D4		     STA   $D4
   775 2425 90 02		     BCC   label64
   776 2427 E6 D5		     INC   $D5
   777 2429			label64
   778 2429 4C E8 23		     JMP   label65
   779 242C			GameNamePrint
   780 242C A5 D9		     LDA   NamesOnScreen
   781 242E 18			     CLC
   782 242F 69 02		     ADC  #$02
   783 2431 8D 38 24		     STA   YposGameName
   784 2434 20 47 2A		     JSR   PrintXY
   785 2437 01			     .BY $01
   786 2438			YposGameName
   787 2438 02			     .BY $02
   788 2439			GameKeySymbol
   789 2439 41 29 20		     .BY "A) "
   790 243C			GameName
   791 243C 20 20 20 20 20 20 +      .BY "                                   "
   792 245F 00			     .BY $00 
   793 2460 A5 D9		     LDA   NamesOnScreen
   794 2462 0A			     ASL
   795 2463 AA			     TAX
   796 2464 A5 D0		     LDA   CurrentFileInfoBuff
   797 2466 9D 31 2C		     STA   FirstSectorsTable,X
   798 2469 A5 D1		     LDA   CurrentFileInfoBuff+1
   799 246B 9D 32 2C		     STA   FirstSectorsTable+1,X
   800 246E A5 D0		     LDA   CurrentFileInfoBuff
   801 2470 18			     CLC
   802 2471 69 17		     ADC  #$17
   803 2473 85 D0		     STA   CurrentFileInfoBuff
   804 2475 90 02		     BCC   label66
   805 2477 E6 D1		     INC   CurrentFileInfoBuff+1
   806 2479			label66
   807 2479 E6 D9		     INC   NamesOnScreen
   808 247B A5 D9		     LDA   NamesOnScreen
   809 247D C9 13		     CMP  #$13
   810 247F B0 42		     BCS   ContArrowsPrint    ; jest wiecej plikow niz sie zmiescilo na ekranie
   811 2481 4C 73 23		     JMP   label68
   812 2484			label59
   813 2484 A5 D0		     LDA   CurrentFileInfoBuff 
   814 2486 18			     CLC
   815 2487 69 17		     ADC  #$17
   816 2489 85 D0		     STA   CurrentFileInfoBuff
   817 248B 90 02		     BCC   label69
   818 248D E6 D1		     INC   CurrentFileInfoBuff+1
   819 248F			label69
   820 248F 4C 73 23		     JMP   label68
   821 2492			MainDirKEY
   822 2492 4C D4 21		     JMP   ReadMainDir
   823 2495			UpDirKEY
   824 2495 A0 02		     LDY  #$02
   825 2497 B1 CA		     LDA  (CurrentDirBuf),Y
   826 2499 AA			     TAX 
   827 249A 88			     DEY
   828 249B 11 CA		     ORA  (CurrentDirBuf),Y 
   829 249D F0 37		     BEQ   KeyboardProc
   830 249F B1 CA		     LDA  (CurrentDirBuf),Y
   831 24A1 A8			     TAY 
   832 24A2 4C 0A 22		     JMP   ReadDIR
   833 24A5			EscKEY
   834 				     ; sprawdzmy czy z Shift
   835 24A5 AD 0F D2		     LDA   SKSTAT   ; jesli jest Shift to czyscimy ekran i do DOS !!!
   836 24A8 29 08			 and   #$08
   837 24AA D0 06		     BNE   NoSHIFTEsc
   838 24AC 20 37 21			 JSR EditorOpen
   839 24AF 6C 0A 00			 JMP (DOSVEC)
   840 24B2			NoSHIFTEsc	 
   841 24B2 A2 00		     LDX  #$00
   842 24B4 86 D8		     STX   $D8 
   843 24B6 E8			     INX 
   844 24B7 86 D7		     STX   $D7
   845 24B9			ToStartOfDirJump
   846 24B9 4C BC 22		     JMP   ToStartOfDir
   847 24BC			SpaceKEY
   848 24BC A5 D6		     LDA   LastFilesPageFlag	; jesli wyswietlona zostala ostatnia strona listy
   849 24BE D0 F9		     BNE   ToStartOfDirJump	; to wyswietlamy liste od poczatku
   850 24C0 4C CD 22		     JMP   StatusBarPrint		; a jesli nie lecimy z wyswietlaniem dalej
   851 				; Wyswietlenie strzalek pokazujacych ze jest wiecej plikow niz miesci sie na ekranie
   852 24C3			ContArrowsPrint
   853 24C3 20 47 2A		     JSR   PrintXY
   854 24C6 01 15		     .BY $01,$15
   855 24C8 1D			     .BY $1D		; strzalka w dol
   856 24C9 00			     .BY $00
   857 24CA 20 47 2A		     JSR   PrintXY
   858 24CD 0E 15		     .BY $0E,$15
   859 24CF 1D			     .BY $1D		; strzalka w dol
   860 24D0 00			     .BY $00
   861 24D1 4C D6 24		     JMP   KeyboardProc
   862 24D4			LastFilesPage
   863 24D4 E6 D6		     INC   LastFilesPageFlag
   864 24D6			KeyboardProc
   865 24D6 AD 27 21			 LDA  NewColors
   866 24D9 D0 0D			 BNE  ColorsAlreadySet
   867 24DB A9 C4		     LDA  #$C4 	; ustawienie koloru t³a i liter
   868 24DD 8D C6 02		     STA   COLPF2S
   869 24E0 8D C8 02		     STA   COLBAKS
   870 24E3 A9 CA			 LDA  #$CA
   871 24E5 8D C5 02			 STA   COLPF1S
   872 24E8			ColorsAlreadySet
   873 24E8 20 FE 2A		     JSR   GetKey
   874 24EB 29 7F		     AND #%01111111  ; eliminujemy invers	 
   875 24ED F0 E7			 BEQ  KeyboardProc  ; na pocz¹tku wykluczamy 0 (znak serduszka) - to dla wygody ustalania numeru napedu
   876 24EF C9 3E		     CMP  #$3E  ; ">"
   877 24F1 F0 9F		     BEQ   MainDirKEY
   878 24F3 C9 3C		     CMP  #$3C  ; "<"
   879 24F5 F0 9E		     BEQ   UpDirKEY
   880 24F7 C9 7E			 CMP  #$7E  ; BackSpace
   881 24F9 F0 9A		     BEQ   UpDirKEY
   882 24FB C9 1B		     CMP  #$1B  ; Esc
   883 24FD F0 A6		     BEQ   EscKEY
   884 24FF C9 20		     CMP  #$20  ; Spacja
   885 2501 F0 B9		     BEQ   SpaceKEY
   886 				     ; ----------------
   887 					 ; sprawdzenie ctrl+A do ctrl+O (kody od $01 do $0f)
   888 2503 C9 10			 CMP #$10
   889 2505 B0 06			 BCS noCtrlLetter ; jesli kod mniejszy od 16 to naped (0 wykluczylismy na poczatku)
   890 2507 20 AC 2B			 JSR SeTDriveLetter
   891 250A 4C 65 21			 JMP mainprog
   892 250D			noCtrlLetter
   893 				     ; sprawdzenie klawiszy 1-8
   894 250D C9 31		     CMP #'1'
   895 250F 90 0D		     BCC NoNumber
   896 2511 C9 39		     CMP #'9'
   897 2513 B0 09		     BCS NoNumber
   898 2515 38			     SEC
   899 2516 E9 30		     SBC #'0'
   900 2518 20 99 2B		     JSR SeTDriveNR
   901 251B 4C 65 21		     JMP mainprog
   902 				     ; -----------------
   903 251E			NoNumber
   904 251E C9 61		     CMP #'a'   ; czy nie ma capsa
   905 2520 90 02			 BCC BigLetters    ; mniejsza od 'a' wiec duza - C tu bedzie skasowany
   906 2522 E9 20			 SBC #$20  ; tu nie trzeba SEC bo C jest zawsze ustawiony (odejmujemy $20 - przestawiamy z malych na duze)
   907 2524			BigLetters
   908 2524 38			     SEC
   909 2525 E9 41		     SBC  #'A'  ; "A"     ; czy klawisz A lub wiekszy
   910 2527 C5 D9		     CMP   NamesOnScreen              ; czy mniejszy lub równy iloœci plików widocznych na ekranie
   911 2529 B0 AB		     BCS   KeyboardProc    ; jesli spoza zakresu wracamy do czekania na klawisz
   912 252B 0A			     ASL 
   913 252C AA			     TAX 
   914 252D BD 31 2C		     LDA   FirstSectorsTable,X
   915 2530 85 D4		     STA   $D4
   916 2532 BD 32 2C		     LDA   FirstSectorsTable+1,X 
   917 2535 85 D5		     STA   $D5
   918 2537 A0 00		     LDY  #$00
   919 2539 B1 D4		     LDA  ($D4),Y
   920 253B 29 20		     AND  #$20             ; sprawdzamy czy to klatalog czy plik
   921 253D F0 15		     BEQ   GOtoLoader     ; jesli plik to skaczemy do pracedury przygotowujacej loader
   922 				     ; a jesli katalog, pobieramy poczatek jego mapy sektorow i odczytujemy go na ekran
   923 253F A0 02		     LDY  #$02
   924 2541 B1 D4		     LDA  ($D4),Y 
   925 2543 AA			     TAX
   926 2544 88			     DEY
   927 2545 B1 D4		     LDA  ($D4),Y
   928 2547 A8			     TAY
   929 2548 4C 0A 22		     JMP   ReadDIR
   930 254B			SubDirText
   931 254B 3C 53 55 42 2D 44 +      .BY "<SUB-DIR>"
   932 2554			GOtoLoader
   933 2554 20 48 2B		     JSR   DiscChangeCheck   ; Sprawdzenie czy w miedzyczasie nie zostala zmieniona dyskietka
   934 2557 F0 03		     BEQ   DiskNotChanged1
   935 2559 4C D4 21		     JMP   ReadMainDir        ; jesli zmieniono to skok na poczatek programu i ponowny odczyt katalogu glownego
   936 255C			DiskNotChanged1
   937 255C AD 26 21			 LDA   FolderTurbo
   938 255F F0 07			 BEQ   SetTurboOFF
   939 2561 AD 0F D2		     LDA   SKSTAT   ; jesli jest Shift to odpowiednio ustawiamy flage przed samym zaladowaniem pliku !!!
   940 2564 29 08			 and   #$08
   941 2566 D0 03		     BNE   NoSHIFT
   942 2568			SetTurboOFF
   943 2568 8D 22 21		     STA   USmode  ; tutaj mamy 0 w A wiec nie potrzeba LDA #0
   944 256B			NoSHIFT
   945 256B A0 01		     LDY  #$01
   946 256D B1 D4		     LDA  ($D4),Y
   947 256F 8D D7 20		     STA   .adr loader.FirstMapSectorNr	; przed przepisaniem
   948 2572 8D 44 2A			 sta  blokDanychIO+$A   ; od razu do bloku IOCB
   949 2575 C8			     INY
   950 2576 B1 D4		     LDA  ($D4),Y
   951 2578 8D D8 20		     STA   .adr loader.FirstMapSectorNr+1	; przed przepisaniem
   952 257B 8D 45 2A			 sta  blokDanychIO+$B   ; od razu do bloku IOCB
   953 257E C8			     INY
   954 257F B1 D4		     LDA  ($D4),Y
   955 2581 49 FF		     EOR  #$FF
   956 2583 8D 21 21		     STA   .adr loader.tempToFileEndL
   957 2586 C8			     INY
   958 2587 B1 D4		     LDA  ($D4),Y
   959 2589 49 FF		     EOR  #$FF
   960 258B 8D 00 20		     STA   .adr loader.ToFileEndH	; przed przepisaniem
   961 258E C8			     INY
   962 258F B1 D4		     LDA  ($D4),Y
   963 2591 49 FF		     EOR  #$FF
   964 2593 8D 01 20		     STA   .adr loader.ToFileEndH+1	; przed przepisaniem
   965 				; wszystko zapamietane mozna robic mape sektorow....
   966 				; skompresowana mapa bedzie tworzona w buforze sektora katalogu
   967 				; czyli DirSectorBuff
   968 				; sektor mapy przed kompresja leci do DirMapSectorBuff
   969 				; UWAGA
   970 				; Zeby dzialala ta ladna procedura Bernaska mapa na poczatku musi
   971 				; zawierac rozkaz przeczytania pierwszego sektora!!!!!
   972 = 2F80			CompressedMap = DirSectorBuff
   973 				; czytamy pierwszy sektor mapy
   974 2596 A0 80			 LDY #<DirMapSectorBuff
   975 2598 A2 2D		     LDX #>DirMapSectorBuff
   976 259A 20 0C 2A			 Jsr ReadSector
   977 				; pobieramy numer pierwszego sektora pliku i od razu robimy wpis w mapie !!!
   978 259D A9 00		     LDA #00
   979 259F 85 82			 STA CompressedMapCounter
   980 25A1 85 83			 STA CompressedMapCounter+1
   981 25A3 20 6F 26			 JSR AddToCompressedMAP
   982 25A6 AD 84 2D		     LDA DirMapSectorBuff+4
   983 25A9 85 86			 STA PrevFileSector
   984 25AB 20 6F 26			 JSR AddToCompressedMAP
   985 25AE AD 85 2D		     LDA DirMapSectorBuff+5
   986 25B1 85 87			 sta PrevFileSector+1
   987 25B3 20 6F 26			 JSR AddToCompressedMAP
   988 				 ; Inicjujemy liczniki
   989 25B6			    .zpvar MapCounter,CompressedMapCounter, MapCounterMem .word =$80
   990 25B6				.zpvar PrevFileSector, MapPositionMem .word
   991 25B6				.zpvar SectorOffset .word
   992 25B6				.zpvar SectorsCounter .byte
   993 25B6 A9 00		     LDA #$00
   994 25B8 85 81			 STA MapCounter+1
   995 25BA 85 8C			 STA SectorsCounter
   996 25BC A9 06			 lda #$06
   997 25BE 85 80			 STA MapCounter
   998 25C0			GenerateCompressedMap
   999 25C0 18			     CLC
  1000 25C1 A9 80			 LDA #<DirMapSectorBuff
  1001 25C3 65 80			 ADC MapCounter
  1002 25C5 85 88			 STA MAPPositionMem
  1003 25C7 A9 2D			 LDA #>DirMapSectorBuff
  1004 25C9 65 81			 ADC MapCounter+1
  1005 25CB 85 89			 STA MAPPositionMem+1
  1006 25CD A2 00			 LDX #0
  1007 25CF A0 01			 LDY #1
  1008 25D1 A1 88		 	 LDA (MAPPositionMem,x)
  1009 25D3 11 88		     ORA (MAPPositionMem),y
  1010 25D5 F0 56			 BEQ Sector00
  1011 25D7 38				 SEC
  1012 25D8 A1 88			 LDA (MAPPositionMem,x)
  1013 25DA E5 86			 SBC PrevFileSector
  1014 25DC 85 8A			 STA SectorOffset
  1015 25DE B1 88			 LDA (MAPPositionMem),y
  1016 25E0 E5 87			 SBC PrevFileSector+1
  1017 25E2 85 8B			 STA SectorOffset+1
  1018 					 ; mamy odstep miedzy poprzednim a nastepnym sektorem
  1019 25E4 D0 26		     BNE OffsetToBig
  1020 25E6 A5 8A			 LDA SectorOffset
  1021 25E8 30 22			 BMI OffsetToBig  ; max przeskok 127 sektorow
  1022 25EA C9 01		     CMP #$01
  1023 25EC D0 11			 BNE JumpForward
  1024 					 ; kolejny sektor
  1025 					 ; zwiekszamy wiec licznik
  1026 25EE E6 8C			 inc SectorsCounter
  1027 25F0 A5 8C			 LDA SectorsCounter
  1028 25F2 C9 7F			 CMP #%01111111
  1029 25F4 D0 2C			 BNE GetNextMapWord
  1030 					 ; tu licznik dotarl do konca zerujemy go
  1031 					 ; dodajemy wpis do skompresowanej mapy i gotowe
  1032 25F6 20 6F 26			 JSR AddToCompressedMAP
  1033 25F9 A9 00			 LDA #0
  1034 25FB 85 8C			 STA SectorsCounter
  1035 25FD F0 23			 BEQ GetNextMapWord
  1036 				; ominiecie wyznaczonej iloœci sektorów (w A)
  1037 25FF			JumpForward
  1038 25FF 20 8A 26		     JSR FlushBuffer
  1039 2602 A5 8A		     LDA SectorOffset
  1040 2604 09 80			 ORA #%10000000
  1041 2606 20 6F 26			 JSR AddToCompressedMAP
  1042 2609 4C 22 26		     JMP GetNextMapWord
  1043 				; wyznaczenie skoku do nowego sektora pliku
  1044 260C			OffsetToBig
  1045 260C 20 8A 26		     JSR FlushBuffer
  1046 260F A9 00		     LDA #0
  1047 2611 20 6F 26			 JSR AddToCompressedMAP
  1048 2614 A0 00			 LDY #00
  1049 2616 B1 88			 LDA (MAPPositionMem),y
  1050 2618 20 6F 26			 JSR AddToCompressedMAP
  1051 261B A0 01		     LDY #01
  1052 261D B1 88			 LDA (MAPPositionMem),y
  1053 261F 20 6F 26			 JSR AddToCompressedMAP
  1054 2622			GetNextMapWord
  1055 				 ; zapamietanie numeru obecnego sektora do porownania potem	 
  1056 2622 A0 00			 LDY #00
  1057 2624 B1 88			 LDA (MAPPositionMem),y
  1058 2626 85 86			 STA PrevFileSector
  1059 2628 C8			     INY
  1060 2629 B1 88			 LDA (MAPPositionMem),y
  1061 262B 85 87			 STA PrevFileSector+1
  1062 262D			Sector00
  1063 262D 18 A5 80 69 02 85 +      ADW MapCounter #2
  1064 2638			ops01
  1065 				     ; CPW MapCounter {.adr loader.SecLen}   ; a to nie dziala
  1066 2638 A5 81			 LDA MapCounter+1
  1067 263A CD A3 20			 CMP .adr loader.SecLen+1
  1068 263D D0 05			 bne noteqal01
  1069 263F A5 80			 LDA MapCounter
  1070 2641 CD A2 20			 CMP .adr loader.SecLen	 
  1071 2644			noteqal01
  1072 2644 F0 03 4C C0 25	     JNE GenerateCompressedMap
  1073 				; czytamy nastepny sektor mapy
  1074 				     ; sprawdzmy czy nie koniec
  1075 2649 AD 80 2D		     LDA DirMapSectorBuff
  1076 264C 0D 81 2D		     ORA DirMapSectorBuff+1
  1077 264F F0 45			 BEQ EndMakingMap
  1078 2651 AD 80 2D		     LDA DirMapSectorBuff
  1079 2654 8D 44 2A			 sta  blokDanychIO+$A
  1080 2657 AD 81 2D			 LDA DirMapSectorBuff+1
  1081 265A 8D 45 2A			 sta  blokDanychIO+$B
  1082 265D A0 80			 LDY #<DirMapSectorBuff
  1083 265F A2 2D		     LDX #>DirMapSectorBuff
  1084 2661 20 0C 2A			 Jsr ReadSector
  1085 					 ; zerujemy licznik mapy
  1086 2664 A9 00		     LDA #$00
  1087 2666 85 81			 STA MapCounter+1
  1088 2668 A9 04			 lda #$04
  1089 266A 85 80			 STA MapCounter
  1090 266C 4C C0 25		     JMP GenerateCompressedMap
  1091 				; dpisanie bajtu z A do mapy sektorow skompresowanej
  1092 266F			AddToCompressedMAP
  1093 266F 48			     PHA
  1094 					 ; wyliczamy adresa
  1095 2670 18				 CLC
  1096 2671 A5 82			 LDA CompressedMapCounter
  1097 2673 69 80			 ADC #<CompressedMap
  1098 2675 8D 81 26			 STA xxxxbla
  1099 2678 A5 83			 LDA CompressedMapCounter+1
  1100 267A 69 2F			 ADC #>CompressedMap
  1101 267C 8D 82 26			 STA xxxxbla+1
  1102 267F 68				 PLA
  1103 = 2681			xxxxbla=*+1
  1104 2680 8D FF FF			 STA $FFFF
  1105 2683 E6 82			 INC CompressedMapCounter
  1106 2685 D0 02			 BNE noinc013
  1107 2687 E6 83			 INC CompressedMapCounter+1
  1108 2689			noinc013
  1109 2689 60			     RTS
  1110 268A			FlushBuffer
  1111 268A A5 8C		     LDA SectorsCounter
  1112 268C F0 07			 BEQ NoFlush
  1113 268E 20 6F 26			 JSR AddToCompressedMAP
  1114 2691 A9 00			 LDA #0
  1115 2693 85 8C		     STA SectorsCounter
  1116 2695			NoFlush
  1117 2695 60			     RTS
  1118 2696			EndMakingMap
  1119 2696 20 8A 26		     JSR FlushBuffer
  1120 2699			LoaderGo
  1121 2699 A0 00		     LDY  #$00
  1122 269B 8C 44 02		     STY   COLDST
  1123 269E A9 01		     LDA  #$01
  1124 26A0 85 09		     STA   BOOT
  1125 26A2 AE 00 07			 LDX  $700
  1126 26A5 E0 53			 CPX  #'S'   ; czy sparta, bo jesli tak, to wylaczamy carta
  1127 26A7 D0 03			 BNE  NoRunFromDOS
  1128 26A9 8D F8 03		     STA   $03F8  ; to wylaczalo BASIC !!!
  1129 				;	 STA   $D5EC  ; to wylacza SpartaDOS X
  1130 				;	 STY   GINTLK ; i mowi OSowi, ze carta nigdy nie bylo :)
  1131 26AC			NoRunFromDOS
  1132 26AC A9 BD		     LDA  #<AfterWormStart
  1133 26AE 85 0C		     STA   DOSINI
  1134 26B0 A9 26		     LDA  #>AfterWormStart
  1135 26B2 85 0D		     STA   DOSINI+1
  1136 				;     LDA  #>JRESETCD
  1137 				;     STA   DOSVEC+1
  1138 				;     LDA  #<JRESETCD
  1139 				;     STA   DOSVEC
  1140 					 ; zapamietanie stanu urzadzen PBI
  1141 26B4 AD 47 02			 LDA PDVMASK
  1142 26B7 8D 24 2C			 STA PDVMASKtemp
  1143 26BA 4C 74 E4		     JMP   JRESETWM        ; wymuszenie cieplego resetu - z ustawionymi odpowiednimi prametrami powrotu
  1144 26BD			AfterWormStart
  1145 				     ; wyznaczamy MEMlo, najpierw dodajemy dlugosc bufora na sektor
  1146 					 ; do koncowego adresu naszej procedury
  1147 					 ; odtworzenie stanu PBI
  1148 26BD AD 24 2C			 LDA PDVMASKtemp
  1149 26C0 8D 47 02			 STA PDVMASK
  1150 				;     JSR EditorOpen   ; zamiast cieplego startu czyszczenie ekranu
  1151 26C3 18				 CLC
  1152 26C4 A9 D7		     LDA   #<TempMEMLO
  1153 26C6 6D A2 20			 ADC   .adr loader.SecLen
  1154 26C9 8D E7 02		     STA   MEMLO
  1155 26CC 85 3D			 STA   CompressedMapPos
  1156 				;	 STA   pointerMov2b-1   ; przygotowanie procedury przepisujacej
  1157 				;     STA   APPMHI           ; wlasciwie tu powinno byc to samo co po pozniejszym zwiekszeniu MEMLO !!!!
  1158 26CE A9 07		     LDA   #>TempMEMLO
  1159 26D0 6D A3 20		     ADC   .adr loader.SecLen+1
  1160 26D3 8D E8 02		     STA   MEMLO+1
  1161 26D6 85 3E			 STA   CompressedMapPos+1
  1162 				;	 STA   pointerMov2b
  1163 				;     STA   APPMHI+1
  1164 					 ; tu w MEMLO mamy pierwszy wolny bajt za buforem sektora
  1165 					 ; jest to jednoczesnie adres umieszczenia skompresowanej
  1166 					 ; mapy sektorow pliku dla loadera ale MINUS 1
  1167 26D8 A5 3D D0 02 C6 3E + 	 DEW   CompressedMapPos
  1168 					 ; teraz trzeba dodac dlugosc skompresowanej mapy bitowej
  1169 					 ; i wpisac w procedurze przepisujacej turbo (modyfikacja kodu)
  1170 26E0 18				 CLC
  1171 26E1 AD E7 02			 LDA MEMLO
  1172 				;	 ADC CompressedMapCounter
  1173 				;	 STA MEMLO
  1174 26E4 8D 96 27			 STA TurboRelocADDR
  1175 26E7 AD E8 02			 LDA MEMLO+1
  1176 				;	 ADC CompressedMapCounter+1
  1177 				;	 STA MEMLO+1
  1178 26EA 8D 97 27			 STA TurboRelocADDR+1
  1179 26ED A9 71		     LDA  #<JTESTROM
  1180 26EF 85 0C		     STA   DOSINI
  1181 26F1 A9 E4		     LDA  #>JTESTROM
  1182 26F3 85 0D		     STA   DOSINI+1
  1183 				;	 DEC   BOOT  ; przestawiamy z 2 na 1 (z CASINI na DOSINI)
  1184 				;     INC   $033D  ; bajty kontrolne zimnego startu
  1185 				;     INC   $033E  ; zmiana ich wartosci wymusza
  1186 				;     DEC   $033F  ; zimny start po RESET  (blokujemy bo niektore gry startujace przez zmiane wektorow i skok do reset nie dzialaja)
  1187 26F5 A2 00		     LDX  #$00
  1188 26F7 86 08			 STX   WARMST    ; zerowanie WARMST informuje programy ze byl zimny reset a nie cieply (The Last Starfighter)
  1189 				;	 STX   BOOT
  1190 				; przepisanie glownej procedury ladujacej - DWIE STRONY pamieci
  1191 26F9			moveloop1
  1192 26F9 BD 00 20		     LDA   movedproc,X
  1193 26FC 9D 00 07		     STA   $0700,X 
  1194 26FF BD 00 21		     LDA   movedproc+$0100,X
  1195 2702 9D 00 08		     STA   $0800,X
  1196 2705 E8			     INX
  1197 2706 D0 F1		     BNE   moveloop1
  1198 				; przepisanie skompresowanej mapy sektorow pliku za bufor sektora
  1199 				/* moveloop2
  1200 				     DEW   CompressedMapCounter    ; zmiejszamy licznik dlugasci mapy
  1201 				pointerMov2a=*+2
  1202 					 LDA   CompressedMap,x     ; kod samomodyfikujacy sie
  1203 				pointerMov2b=*+2
  1204 				     STA   $FFFF,x              ; kod samomodyfikujacy sie
  1205 					 LDA   CompressedMapCounter
  1206 					 AND   CompressedMapCounter+1
  1207 				     CMP   #$FF                      ; jesli licznik = -1 to przepisalismy cala mape !!!
  1208 					 BEQ   SectorMapReady
  1209 				  	 INX
  1210 					 BNE   moveloop2
  1211 					 inc   pointerMov2a
  1212 					 inc   pointerMov2b
  1213 					 bne   moveloop2 
  1214 				SectorMapReady
  1215 				 */
  1215
  1216 2708 20 58 27		     JSR   ADDspeedProc   ; procedura relokujaca procedury turbo (jesli potrzebne) i podnaszaca odpowiednio MEMLO
  1217 270B 20 C8 2B			 JSR   MEMLOprint     ; wyswietlenie wartosci MEMLO (moze wyswietlac i inne rzeczy)
  1218
  1219 270E A2 00		     LDX  #$00
  1220 2710 8A			     TXA
  1221 				; wstepne czyszczenie (reszte RAM czysci procedura ladujaca - dzieki czemu czysci tez program glowny)
  1222 2711			ClearLoop1
  1223 2711 9D 00 01		     STA   $0100,X 		; STOS !!!
  1224 2714 9D 00 04		     STA   $0400,X			; bufor magnetofonu (128) i obszar zarezerwowany?? (drugie 128b)
  1225 2717 9D 00 05		     STA   $0500,X 
  1226 271A 9D 00 06		     STA   $0600,X 
  1227 271D E0 80		     CPX  #$80             ;tylko ponad $80
  1228 271F 90 02		     BCC   NoZpage
  1229 2721 95 00		     STA   $00,X           ; czyli polowa strony zerowej
  1230 2723			NoZpage
  1231 2723 E8			     INX
  1232 2724 D0 EB		     BNE   ClearLoop1
  1233 2726 A2 FF		     LDX  #$FF
  1234 2728 9A			     TXS 					; "wyzerowanie wskaznika STOSU
  1235 				     
  1236 				     ; a tutaj otwieramy kanal 1 CIO do odczytu 
  1237
  1238 2729 A2 10		      LDX #16 ; kanal 1
  1239 272B A9 03		      LDA #COPN ; rozkaz OPEN
  1240 272D 9D 42 03		      STA ICCOM,X ; COMMAND
  1241 2730 A9 04		        LDA #$04    ; READ
  1242 2732 9D 4A 03		        STA ICAUX1,X
  1243 2735 A9 00		        LDA #$00
  1244 2737 9D 4B 03		        STA ICAUX2,X
  1245 273A A9 4A		      LDA # <FileToOpen
  1246 273C 9D 44 03		      STA ICBADR,X
  1247 273F A9 27		      LDA # >FileToOpen
  1248 2741 9D 45 03		      STA ICBADR+1,X
  1249 2744 20 56 E4		      JSR CIO
  1250 					 
  1251 2747 4C D9 07		     JMP   loader.LoadStart     ; po przepisaniu 
  1252 274A			FileToOpen
  1253 274A 28 1A 33 23 2F 32 +      .BYTE "H:SCORCH.XEX",155,0
  1254 				; Sprawdzenie odpowiednich flag i przepisanie za loaderem procedury obslugi odpowiedniego Turba
  1255 				; na koniec odpowiednie zmodyfikowanie MEMLO
  1256 2758			ADDspeedProc
  1257 2758 AD 22 21		     LDA   USmode
  1258 275B F0 5F			 beq   NoHappyLoader
  1259 				; wyznaczamy offset procedury
  1260 275D 38			    SEC
  1261 275E A9 BD			LDA #<HappyUSMovedProc
  1262 2760 ED E7 02			SBC MEMLO
  1263 2763 8D 19 2C			STA HappyOffset
  1264 2766 A9 27			LDA #>HappyUSMovedProc
  1265 2768 ED E8 02			SBC MEMLO+1
  1266 276B 8D 1A 2C			STA HappyOffset+1
  1267
  1268 276E A0 00			LDY #0
  1269 2770 A2 09			LDX #[$A-1]  ;xjsrA - the last
  1270 					; relokujemy skoki pod offset z MEMLO
  1271 2772			HappyRelocate
  1272 2772 38				SEC
  1273 2773 BD 05 2C			LDA xjsrTableL,x
  1274 2776 85 32			STA SecBuffer
  1275 2778 BD 0F 2C			LDA xjsrTableH,x
  1276 277B 85 33			STA SecBuffer+1
  1277 277D B1 32			LDA (SecBuffer),y
  1278 277F ED 19 2C			SBC HappyOffset
  1279 2782 91 32			STA (SecBuffer),y
  1280 2784 C8				INY
  1281 2785 B1 32			LDA (SecBuffer),y
  1282 2787 ED 1A 2C			SBC HappyOffset+1
  1283 278A 91 32			STA (SecBuffer),y
  1284 278C 88				DEY
  1285 278D CA				DEX
  1286 278E 10 E2			BPL HappyRelocate
  1287
  1288 2790 A2 FE		     LDX  #[EndHappyUSProc-HappyUSMovedProc-1]
  1289 2792			label72x
  1290 2792 BD BD 27		     LDA   HappyUSMovedProc,X
  1291 = 2796			TurboRelocADDR=*+1
  1292 2795 9D 00 0A		     STA   $0A00,X
  1293 2798 CA			     DEX
  1294 2799 E0 FF			 CPX #$FF
  1295 279B D0 F5		     BNE   label72x
  1296 279D A0 FF		   LDY   #[EndHappyUSProc-HappyUSMovedProc]
  1297 279F A2 00		     LDX   #$00
  1298 				; Zwiekszenie Memlo o dlugosc procedury i przelaczenie skoku do niej.
  1299 27A1			label73
  1300 27A1 98			     TYA
  1301 27A2 18			     CLC
  1302 27A3 6D E7 02		     ADC   MEMLO
  1303 27A6 8D E7 02		     STA   MEMLO
  1304 27A9 8A			     TXA
  1305 27AA 6D E8 02		     ADC   MEMLO+1
  1306 27AD 8D E8 02		     STA   MEMLO+1
  1307 27B0 AD 96 27		     LDA   TurboRelocADDR
  1308 27B3 8D 97 07		     STA   loader.SioJMP+1               ; po przepisaniu
  1309 27B6 AD 97 27		     LDA   TurboRelocADDR+1
  1310 27B9 8D 98 07		     STA   loader.SioJMP+2             ; po przepisaniu
  1311 27BC			NoHappyLoader
  1312 27BC 60			     RTS
  1313
  1314
  1315
  1316 				; UWAGA !!!!!!!!!!!!!!
  1317 				; Ta procedura ma maksymalna dlugosc jaka moze miec!!!!!
  1318 				; powiekszenie jej O BAJT spowoduje ze przekroczy strone
  1319 				; i nie przepisze sie prawidlowo na swoje miejsce !!!!!	 
  1320 27BD			HappyUSMovedProc ;
  1321
  1322 27BD AD 04 03			LDA DBUFA
  1323 27C0 85 32			STA SecBuffer
  1324 27C2 AD 05 03			LDA DBUFA+1
  1325 27C5 85 33			STA SecBuffer+1
  1326
  1327 27C7 AD 08 03			LDA DBYT
  1328 27CA 85 31			STA SecLenUS
  1329
  1330 27CC 78				SEI
  1331 27CD BA				TSX
  1332 27CE 86 37			STX StackCopy
  1333 27D0 A9 0D			LDA #$0D
  1334 27D2 85 34			STA CRETRYZ
  1335 					 ;command retry on zero page
  1336 27D4			CommandLoop
  1337 = 27D5			HappySpeed = *+1
  1338 27D4 A9 28			LDA #$28 ;here goes speed from "?"
  1339 27D6 8D 04 D2			STA AUDF3
  1340 27D9 A9 34			LDA #$34
  1341 27DB 8D 03 D3			STA PBCTL ;ustawienie linii command
  1342 27DE A2 80			LDX #$80
  1343 27E0			DelayLoopCmd
  1344 27E0 CA				DEX
  1345 27E1 D0 FD			BNE DelayLoopCmd
  1346 27E3 8E 06 D2			STX AUDF4 ; zero
  1347 27E6 86 35			STX TransmitError
  1348 				;	pokey init
  1349 27E8 A9 23			LDA #$23
  1350 27EA 20 5E 28		xjsr1	JSR SecTransReg
  1351 					;
  1352
  1353 27ED 18				CLC
  1354 27EE AD 00 03			LDA DDEVIC    ; tu zawsze jest $31 (przynajmniej powinno)
  1355 27F1 6D 01 03			ADC DUNIT     ; dodajemy numer stacji
  1356 27F4 69 FF			ADC #$FF	; i odejmujemy jeden (jak w systemie Atari)
  1357 27F6 85 30			STA CheckSum
  1358 27F8 8D 0D D2			STA SEROUT
  1359 27FB AD 02 03			LDA DCOMND
  1360 27FE 20 74 28		xjsr2	JSR PutSIOByte
  1361 2801 AD 0A 03			LDA DAUX1
  1362 2804 20 74 28		xjsr3	JSR PutSIOByte
  1363 2807 AD 0B 03			LDA DAUX2
  1364 280A 20 74 28		xjsr4	JSR PutSIOByte
  1365 280D A5 30			LDA CheckSum
  1366 280F 20 74 28		xjsr5	JSR PutSIOByte
  1367
  1368 2812			waitforEndOftransmission
  1369 2812 AD 0E D2			LDA IRQST
  1370 2815 29 08			AND #$08
  1371 2817 D0 F9			BNE waitforEndOftransmission
  1372
  1373 2819 A9 13			LDA #$13
  1374 281B 20 5E 28		xjsr6	JSR SecTransReg
  1375
  1376 281E A9 3C			LDA #$3c
  1377 2820 8D 03 D3			STA PBCTL ;command line off
  1378 				; two ACK's
  1379 2823 A0 02			LDY #2
  1380 2825			DoubleACK
  1381 2825 20 90 28		xjsr7	JSR GetSIOByte
  1382 2828 C9 44			CMP #$44
  1383 282A B0 19			BCS ErrorHere
  1384 282C 88				DEY
  1385 282D D0 F6			BNE DoubleACK
  1386
  1387 					;ldy #0
  1388 282F 84 30			STY CheckSum
  1389 2831			ReadSectorLoop
  1390 2831 20 90 28		xjsr8	JSR GetSIOByte
  1391 2834 91 32			STA (SecBuffer),y
  1392 2836 20 88 28		xjsr9	JSR AddCheckSum
  1393 2839 C8				INY
  1394 283A C4 31			CPY SecLenUS
  1395 283C D0 F3			BNE ReadSectorLoop
  1396
  1397 283E 20 90 28		xjsrA	JSR GetSIOByte
  1398 2841 C5 30			CMP CheckSum
  1399 2843 F0 0B			BEQ EndOfTransmission
  1400 				;error!!!
  1401 2845			ErrorHere
  1402 2845 A0 90			LDY #$90
  1403 2847 84 35			STY TransmitError
  1404 2849 A6 37			LDX StackCopy
  1405 284B 9A				TXS
  1406 284C C6 34			DEC CRETRYZ
  1407 284E D0 84			BNE CommandLoop
  1408
  1409 2850			EndOfTransmission
  1410 2850 A9 00			LDA #0
  1411 2852 8D 07 D2			STA AUDC4
  1412 2855 A5 10			LDA IRQENS
  1413 2857 8D 0E D2			STA IRQEN
  1414 285A 58				CLI
  1415 285B A4 35			LDY TransmitError
  1416 285D 60				RTS
  1417
  1418 285E			SecTransReg
  1419 285E 8D 0F D2			STA SKCTL
  1420 2861 8D 0A D2			STA SKSTRES
  1421 2864 A9 38			LDA #$38
  1422 2866 8D 0E D2			STA IRQEN
  1423 2869 A9 28			LDA #$28
  1424 286B 8D 08 D2			STA AUDCTL
  1425 286E A9 A8			LDA #$A8
  1426 2870 8D 07 D2			STA AUDC4
  1427 2873 60				RTS
  1428
  1429 2874			PutSIOByte
  1430 2874 AA				TAX
  1431 2875			waitforSerial
  1432 2875 AD 0E D2			LDA IRQST
  1433 2878 29 10			AND #$10
  1434 287A D0 F9			BNE waitforSerial
  1435
  1436 287C 8D 0E D2			STA IRQEN
  1437 287F A9 10			LDA #$10
  1438 2881 8D 0E D2			STA IRQEN
  1439
  1440 2884 8A				TXA
  1441 2885 8D 0D D2			STA SEROUT
  1442
  1443 2888			AddCheckSum
  1444 2888 18				CLC
  1445 2889 65 30			ADC CheckSum
  1446 288B 69 00			ADC #0
  1447 288D 85 30			STA CheckSum
  1448 288F 60				RTS
  1449
  1450 2890			GetSIOByte
  1451 2890 A2 0A			LDX #10  ;acktimeout
  1452 2892			ExternalLoop
  1453 2892 A9 00			LDA #0
  1454 2894 85 36			STA looperka
  1455 2896			InternalLoop
  1456 2896 AD 0E D2			LDA IRQST
  1457 2899 29 20			AND #$20
  1458 289B F0 09			BEQ ACKReceive
  1459 289D C6 36			DEC looperka
  1460 289F D0 F5			BNE InternalLoop
  1461 28A1 CA				DEX
  1462 28A2 D0 EE			BNE ExternalLoop
  1463 28A4 F0 9F			BEQ ErrorHere
  1464 28A6			ACKReceive
  1465 					; zero we have now
  1466 28A6 8D 0E D2			STA IRQST
  1467 28A9 A9 20			LDA #$20
  1468 28AB 8D 0E D2			STA IRQST
  1469 28AE AD 0F D2			LDA SKSTAT
  1470 28B1 8D 0A D2			STA SKSTRES
  1471 28B4 29 20			AND #$20
  1472 28B6 F0 8D			BEQ ErrorHere
  1473 					;
  1474 28B8 AD 0D D2			LDA SERIN
  1475 28BB 60				RTS
  1476 28BC			EndHappyUSProc
  1477
  1478
  1479 				; Rozkaz DCB "?" pobierrajacy predkosc dla Happy i US-Doubler
  1480 28BC			blokDanychIO_GetUSSpeed
  1481 28BC 31 01 3F 40		     .BY $31,$01,"?",$40
  1482 28C0 D5 27		     .WO HappySpeed
  1483 28C2 07 00 01 00 00 0A	     .BY $07,$00,$01,$00,$00,$0A
  1484 28C8			DirMapEnd
  1485 28C8 4C 94 29		     JMP   label75
  1486 28CB			label39
  1487 28CB 85 DA		     STA   $DA 
  1488 28CD A5 D0		     LDA   CurrentFileInfoBuff
  1489 28CF 85 DB		     STA   $DB
  1490 28D1 A5 D1		     LDA   CurrentFileInfoBuff+1
  1491 28D3 85 DC		     STA   $DC
  1492 28D5 20 48 2B		     JSR   DiscChangeCheck   ; Sprawdzenie czy w miedzyczasie nie zostala zmieniona dyskietka
  1493 28D8 F0 05		     BEQ   DiscNotChanged2
  1494 28DA 68			     PLA
  1495 28DB 68			     PLA
  1496 28DC 4C D4 21		     JMP   ReadMainDir
  1497 28DF			DiscNotChanged2
  1498 				     ; odczyt sektora mapy wskazywanego przez DirMapSec
  1499 28DF A5 D2		     LDA   DirMapSect
  1500 28E1 8D 44 2A		     STA   blokDanychIO+10
  1501 28E4 A5 D3		     LDA   DirMapSect+1
  1502 28E6 8D 45 2A		     STA   blokDanychIO+11
  1503 28E9 0D 44 2A		     ORA   blokDanychIO+10
  1504 28EC F0 DA		     BEQ   DirMapEnd
  1505 28EE A2 2D		     LDX  #>DirMapSectorBuff
  1506 28F0 A0 80		     LDY  #<DirMapSectorBuff
  1507 28F2 20 0C 2A		     JSR   ReadSector
  1508 					 ; zostal wczytany kolejny sektor mapy nalezy wiec zapamietac we wskazniku DirMapSec
  1509 					 ; numer nastepnego sektora mapy. To 2 pierwsze bajty z bufora na sektor mapy
  1510 28F5 AD 80 2D		     LDA   DirMapSectorBuff
  1511 28F8 85 D2		     STA   DirMapSect
  1512 28FA AD 81 2D		     LDA   DirMapSectorBuff+1
  1513 28FD 85 D3		     STA   DirMapSect+1
  1514 28FF A9 04		     LDA  #$04 
  1515 2901 85 E2			 STA   InMapPointer		; --
  1516 2903 A9 00			 LDA  #$00					; --
  1517 2905 85 E3			 STA   InMapPointer+1		; --
  1518 2907			label80
  1519 2907 A4 E2			 LDY   InMapPointer		; --
  1520 2909 CC A2 20		     CPY   .adr loader.SecLen	; przed przepisaniem
  1521 290C D0 07			 BNE   NoNextMapSector		; --
  1522 290E A5 E3			 LDA   InMapPointer+1			; --
  1523 2910 CD A3 20			 CMP   .adr loader.Seclen+1	; --
  1524 2913 F0 CA		     BEQ   DiscNotChanged2
  1525 2915			NoNextMapSector
  1526 					; pobranie numeru nastepnego sektora katalogu z mapy sektorow
  1527 					 ; tymczasowy adrez na ZP
  1528 2915 A9 80			 LDA  #<DirMapSectorBuff		; --
  1529 2917 85 E4			 STA   TempZP					; --
  1530 2919 18				 CLC							; --
  1531 291A A9 2D			 LDA  #>DirMapSectorBuff		; --
  1532 291C 65 E3			 ADC   InMapPointer+1			; --
  1533 291E 85 E5			 STA   TempZP+1				; --
  1534 2920 B1 E4		     LDA   (TempZP),Y
  1535 2922 8D 44 2A		     STA   blokDanychIO+10
  1536 2925 C8			     INY
  1537 2926 B1 E4		     LDA   (TempZP),Y
  1538 2928 8D 45 2A		     STA   blokDanychIO+11
  1539 292B 0D 44 2A		     ORA   blokDanychIO+10 
  1540 292E F0 64		     BEQ   label75
  1541 					 ; i zwiekszenie wskaznika mapy o 2
  1542 2930 C8			     INY
  1543 2931 84 E2			 STY   InMapPointer
  1544 2933 D0 02			 BNE   NoIncH				; --
  1545 2935 E6 E3			 INC   InMapPointer+1		; --
  1546 2937			NoIncH
  1547 2937 AD E5 02		     LDA   MEMTOP
  1548 293A 38			     SEC
  1549 293B E5 D0		     SBC   CurrentFileInfoBuff
  1550 293D AD E6 02		     LDA   MEMTOP+1
  1551 2940 E5 D1		     SBC   CurrentFileInfoBuff+1
  1552 2942 F0 50		     BEQ   label75
  1553 2944 A4 D0		     LDY   CurrentFileInfoBuff
  1554 2946 A6 D1		     LDX   CurrentFileInfoBuff+1
  1555 2948 20 0C 2A		     JSR   ReadSector
  1556 294B A5 D4		     LDA   $D4
  1557 294D 05 D5		     ORA   $D5
  1558 294F D0 16		     BNE   label79
  1559 2951 A0 03		     LDY  #$03
  1560 2953 B1 D0		     LDA  (CurrentFileInfoBuff),Y
  1561 2955 85 D4		     STA   $D4
  1562 2957 C8			     INY
  1563 2958 B1 D0		     LDA  (CurrentFileInfoBuff),Y
  1564 295A 85 D5		     STA   $D5
  1565 295C C8			     INY
  1566 295D B1 D0		     LDA  (CurrentFileInfoBuff),Y
  1567 295F F0 06		     BEQ   label79
  1568 2961 A9 FF		     LDA  #$FF
  1569 2963 85 D4		     STA   $D4
  1570 2965 85 D5		     STA   $D5
  1571 2967			label79
  1572 2967 A5 D0		     LDA   CurrentFileInfoBuff
  1573 2969 18			     CLC
  1574 296A 6D A2 20		     ADC   .adr loader.SecLen	; przed przepisaniem
  1575 296D 85 D0		     STA   CurrentFileInfoBuff
  1576 296F A5 D1		     LDA   CurrentFileInfoBuff+1
  1577 2971 6D A3 20		     ADC   .adr loader.SecLen+1	; przed przepisaniem
  1578 2974 85 D1		     STA   CurrentFileInfoBuff+1
  1579 2976 A5 D4		     LDA   $D4
  1580 2978 38			     SEC
  1581 2979 ED A2 20		     SBC   .adr loader.SecLen	; przed przepisaniem
  1582 297C 85 D4		     STA   $D4
  1583 297E A5 D5		     LDA   $D5
  1584 2980 ED A3 20		     SBC   .adr loader.SecLen+1	; przed przepisaniem
  1585 2983 85 D5		     STA   $D5
  1586 2985 B0 80		     BCS   label80
  1587 2987 A5 D0		     LDA   CurrentFileInfoBuff
  1588 2989 18			     CLC 
  1589 298A 65 D4		     ADC   $D4 
  1590 298C 85 D0		     STA   CurrentFileInfoBuff
  1591 298E A5 D1		     LDA   CurrentFileInfoBuff+1
  1592 2990 65 D5		     ADC   $D5
  1593 2992 85 D1		     STA   CurrentFileInfoBuff+1
  1594 2994			label75
  1595 2994 A5 DC		     LDA   $DC
  1596 2996 C5 D1		     CMP   CurrentFileInfoBuff+1
  1597 2998 90 0B		     BCC   label81 
  1598 299A D0 17		     BNE   label82
  1599 299C A5 DB		     LDA   $DB
  1600 299E C5 D0		     CMP   CurrentFileInfoBuff
  1601 29A0 90 03		     BCC   label81
  1602 29A2 D0 0F		     BNE   label82
  1603 29A4 60			     RTS
  1604 29A5			label81
  1605 29A5 A5 DB		     LDA   $DB
  1606 29A7 18			     CLC
  1607 29A8 65 DA		     ADC   $DA
  1608 29AA 85 DB		     STA   $DB
  1609 29AC 90 E6		     BCC   label75
  1610 29AE E6 DC		     INC   $DC
  1611 29B0 4C 94 29		     JMP   label75
  1612 29B3			label82
  1613 29B3 A5 DB		     LDA   $DB
  1614 29B5 38			     SEC
  1615 29B6 E5 DA		     SBC   $DA
  1616 29B8 85 D0		     STA   CurrentFileInfoBuff
  1617 29BA A5 DC		     LDA   $DC
  1618 29BC E9 00		     SBC  #$00
  1619 29BE 85 D1		     STA   CurrentFileInfoBuff+1
  1620 29C0 60			     RTS
  1621 				; odczyt bloku PERCOM i ustalenie rozmiaru pierwszego sektora
  1622 29C1			ReadPERCOM
  1623 29C1 A9 04		     LDA  #$04
  1624 29C3 8D 46 2A		     STA   DiskRetryCount
  1625 29C6			ReadPERCOMretry
  1626 29C6 A0 EA		     LDY  #<blokDanychIO_PERCOM
  1627 29C8 A2 29		     LDX  #>blokDanychIO_PERCOM
  1628 29CA 20 E2 2A		     JSR   Table2DCB
  1629 29CD 20 D7 2A		     JSR   GoSIO
  1630 29D0 30 08		     BMI   PercomError
  1631 					 ; blok odczytany - ustawmy dlugosc 1 sektora
  1632 29D2 AD 2B 2C			 LDA   PERCOMdata+6
  1633 29D5 C9 01			 CMP   #$01			; jesli dlugosc sektora to 256b - pierwszy sektor ustawiamy na 128
  1634 29D7 F0 06			 BEQ   Set1Sect128  ; w pozostalych wypadkach zostawiamy jak jest
  1635 29D9 60			     RTS 
  1636 29DA			PercomError
  1637 29DA CE 46 2A		     DEC   DiskRetryCount
  1638 29DD D0 E7		     BNE   ReadPERCOMretry
  1639 					 ; blok nieodczytany - dlugosc 1 sektora na $80
  1640 29DF			Set1Sect128
  1641 29DF A9 00		     LDA  #$00
  1642 29E1 8D 2B 2C			 STA   PERCOMdata+6
  1643 29E4 A9 80			 LDA  #$80
  1644 29E6 8D 2C 2C			 STA   PERCOMdata+7
  1645 29E9 60				 RTS
  1646 29EA			blokDanychIO_PERCOM
  1647 29EA 31 01 4E 40		     .BY $31,$01,$4E,$40
  1648 29EE 25 2C		     .WO PERCOMdata
  1649 29F0 0A 00 0C 00 01 00	     .BY $0A,$00,12,$00,$01,$00
  1650 				; wczytuje pierwszy sektor dysku pod adres zawarty w X(starszy) i Y(mlodszy)
  1651 29F6			ReadFirstSect
  1652 29F6 A9 01		     LDA  #$01
  1653 29F8 8D 44 2A		     STA   blokDanychIO+10 
  1654 29FB A9 00		     LDA  #$00 
  1655 29FD 8D 45 2A		     STA   blokDanychIO+11
  1656 2A00 AD 2B 2C			 LDA   PERCOMdata+6
  1657 2A03 8D 43 2A			 STA   blokDanychIO+9		; --- obsluga sektorow ponad 256b
  1658 2A06 AD 2C 2C		     LDA   PERCOMdata+7
  1659 2A09 4C 15 2A		     JMP   ReadSector1
  1660 				; Wczytuje sektror ustalajac jego dlugosc na podstawie blokDanychIO_Loader (SecLen)
  1661 				; reszta danych jak nizej (A nie wazne)
  1662 2A0C			ReadSector
  1663 2A0C AD A3 20		     LDA   .adr loader.SecLen+1		; --- obsluga sektorow ponad 256b
  1664 2A0F 8D 43 2A			 STA   blokDanychIO+9			; --- obsluga sektorow ponad 256b
  1665 2A12 AD A2 20		     LDA   .adr loader.SecLen	; przed przepisaniem
  1666 2A15			ReadSector1
  1667 2A15 8D 42 2A		     STA   blokDanychIO+8
  1668 2A18 8E 3F 2A		     STX   blokDanychIO+5
  1669 2A1B 8C 3E 2A		     STY   blokDanychIO+4 
  1670 2A1E A9 04		     LDA  #$04
  1671 2A20 8D 46 2A		     STA   DiskRetryCount
  1672 2A23			DiskReadRetry
  1673 2A23 A0 3A		     LDY  #<blokDanychIO
  1674 2A25 A2 2A		     LDX  #>blokDanychIO
  1675 2A27 20 E2 2A		     JSR   Table2DCB
  1676 2A2A 20 D7 2A		     JSR   GoSIO
  1677 2A2D 30 01		     BMI   label85
  1678 2A2F 60			     RTS 
  1679 2A30			label85
  1680 2A30 CE 46 2A		     DEC   DiskRetryCount
  1681 2A33 D0 EE		     BNE   DiskReadRetry 
  1682 2A35 68			     PLA
  1683 2A36 68			     PLA
  1684 2A37 4C 93 21		     JMP   ErrorDisplay
  1685 2A3A			blokDanychIO
  1686 2A3A 31 01 52 40		     .BY $31,$01,$52,$40
  1687 2A3E 80 2D		     .WO DirMapSectorBuff
  1688 2A40 0A 00 80 00 01 00	     .BY $0A,$00,$80,$00,$01,$00
  1689 2A46			DiskRetryCount
  1690 2A46 00			     .BY $00
  1691 2A47			PrintXY
  1692 2A47 68			     PLA
  1693 2A48 85 C8		     STA   $C8
  1694 2A4A 68			     PLA
  1695 2A4B 85 C9		     STA   $C9
  1696 2A4D A9 00		     LDA  #$00
  1697 2A4F 85 DF		     STA   $DF
  1698 2A51 20 C9 2A		     JSR   label87
  1699 2A54 48			     PHA
  1700 2A55 20 C9 2A		     JSR   label87
  1701 2A58 85 DE		     STA   $DE
  1702 2A5A 0A			     ASL
  1703 2A5B 0A			     ASL
  1704 2A5C 18			     CLC
  1705 2A5D 65 DE		     ADC   $DE
  1706 2A5F 0A			     ASL
  1707 2A60 0A			     ASL
  1708 2A61 26 DF		     ROL   $DF
  1709 2A63 0A			     ASL
  1710 2A64 26 DF		     ROL   $DF
  1711 2A66 18			     CLC
  1712 2A67 65 58		     ADC   SAVMSC
  1713 2A69 85 DE		     STA   $DE
  1714 2A6B A5 DF		     LDA   $DF
  1715 2A6D 65 59		     ADC   SAVMSC+1
  1716 2A6F 85 DF		     STA   $DF
  1717 2A71 68			     PLA
  1718 2A72 A8			     TAY
  1719 2A73			label92
  1720 2A73 20 C9 2A		     JSR   label87
  1721 2A76 C9 00		     CMP  #$00
  1722 2A78 F0 48		     BEQ   label88
  1723 2A7A C9 7D		     CMP  #$7D
  1724 2A7C F0 21		     BEQ   label89
  1725 2A7E A2 00		     LDX  #$00
  1726 2A80 86 E0		     STX   $E0 
  1727 2A82 C9 80		     CMP  #$80
  1728 2A84 66 E0		     ROR   $E0
  1729 2A86 29 7F		     AND  #$7F
  1730 2A88 C9 20		     CMP  #$20 
  1731 2A8A B0 04		     BCS   label90 
  1732 2A8C 09 40		     ORA  #$40
  1733 2A8E D0 07		     BNE   label91
  1734 2A90			label90
  1735 2A90 C9 60		     CMP  #$60
  1736 2A92 B0 03		     BCS   label91
  1737 2A94 38			     SEC
  1738 2A95 E9 20		     SBC  #$20
  1739 2A97			label91
  1740 2A97 05 E0		     ORA   $E0
  1741 2A99 91 DE		     STA  ($DE),Y
  1742 2A9B C8			     INY
  1743 2A9C 4C 73 2A		     JMP   label92 
  1744 2A9F			label89
  1745 2A9F 98			     TYA
  1746 2AA0 48			     PHA
  1747 2AA1 A5 58		     LDA   SAVMSC
  1748 2AA3 85 E0		     STA   $E0
  1749 2AA5 A9 03		     LDA  #$03
  1750 2AA7 AA			     TAX
  1751 2AA8 18			     CLC 
  1752 2AA9 65 59		     ADC   SAVMSC+1
  1753 2AAB 85 E1		     STA   $E1
  1754 2AAD A0 BF		     LDY  #$BF
  1755 2AAF A9 00		     LDA  #$00
  1756 2AB1			label93
  1757 2AB1 91 E0		     STA  ($E0),Y
  1758 2AB3 88			     DEY
  1759 2AB4 C0 FF		     CPY  #$FF
  1760 2AB6 D0 F9		     BNE   label93
  1761 2AB8 C6 E1		     DEC   $E1
  1762 2ABA CA			     DEX
  1763 2ABB 10 F4		     BPL   label93
  1764 2ABD 68			     PLA
  1765 2ABE A8			     TAY
  1766 2ABF 4C 73 2A		     JMP   label92
  1767 2AC2			label88
  1768 2AC2 A5 C9		     LDA   $C9
  1769 2AC4 48			     PHA
  1770 2AC5 A5 C8		     LDA   $C8
  1771 2AC7 48			     PHA 
  1772 2AC8 60			     RTS
  1773 2AC9			label87
  1774 2AC9 E6 C8		     INC   $C8
  1775 2ACB D0 02		     BNE   label94
  1776 2ACD E6 C9		     INC   $C9
  1777 2ACF			label94
  1778 2ACF A2 00		     LDX  #$00 
  1779 2AD1 A1 C8		     LDA  ($C8,X) 
  1780 2AD3 60			     RTS
  1781 2AD4			GoErrorDisp
  1782 2AD4 4C 93 21		     JMP   ErrorDisplay
  1783 				; Skok do Sio lub procedury Turbo
  1784 2AD7			GoSIO
  1785 2AD7 AC 22 21		     LDY  USmode
  1786 2ADA F0 03		     BEQ  StandardSpeed
  1787 2ADC 4C BD 27		     JMP  HappyUSMovedProc ; mozna skakac do tej procki
  1788 2ADF			StandardSpeed
  1789 2ADF 4C 59 E4		     JMP   JSIOINT
  1790 				; Przepisuje 12 bajtow z adresy podanego w X(starszy) i Y(mlodszy)
  1791 				; do bloku kontroli transmisji szeregowej DCB
  1792 2AE2			Table2DCB
  1793 2AE2 8C EB 2A		     STY   IOtableAddr+1
  1794 2AE5 8E EC 2A		     STX   IOtableAddr+2
  1795 2AE8 A2 0B		     LDX  #$0B
  1796 2AEA			IOtableAddr
  1797 2AEA BD FF FF		     LDA   $FFFF,X 
  1798 2AED 9D 00 03		     STA   DDEVIC,X
  1799 2AF0 CA			     DEX 
  1800 2AF1 10 F7		     BPL   IOtableAddr
  1801 2AF3 60			     RTS
  1802 2AF4			Close1
  1803 2AF4 A2 10		     LDX  #$10 
  1804 2AF6			CloseX
  1805 2AF6 A9 0C		     LDA  #$0C
  1806 2AF8 9D 42 03		     STA   ICCMD,X
  1807 2AFB 4C 56 E4		     JMP   JCIOMAIN 
  1808 2AFE			GetKey
  1809 2AFE A2 10		     LDX  #$10
  1810 2B00 A9 03		     LDA  #$03
  1811 2B02 9D 42 03		     STA   ICCMD,X 
  1812 2B05 A9 04		     LDA  #$04
  1813 2B07 9D 4A 03		     STA   ICAX1,X
  1814 2B0A A9 00		     LDA  #$00
  1815 2B0C 9D 4B 03		     STA   ICAX2,X
  1816 2B0F 9D 49 03		     STA   ICBUFL+1,X
  1817 2B12 A9 FF		     LDA  #$FF
  1818 2B14 9D 48 03		     STA   ICBUFL,X
  1819 2B17 A9 45		     LDA  #<Kdriver
  1820 2B19 9D 44 03		     STA   ICBUFA,X
  1821 2B1C A9 2B		     LDA  #>Kdriver
  1822 2B1E 9D 45 03		     STA   ICBUFA+1,X
  1823 2B21 20 56 E4		     JSR   JCIOMAIN
  1824 2B24 30 1C		     BMI   GKeyError
  1825 2B26 A2 10		     LDX  #$10
  1826 2B28 A9 00		     LDA  #$00
  1827 2B2A 9D 48 03		     STA   ICBUFL,X
  1828 2B2D 9D 49 03		     STA   ICBUFL+1,X
  1829 2B30 A9 07		     LDA  #$07
  1830 2B32 9D 42 03		     STA   ICCMD,X
  1831 2B35 20 56 E4		     JSR   JCIOMAIN
  1832 2B38 30 08		     BMI   GKeyError
  1833 2B3A 48			     PHA
  1834 2B3B 20 F4 2A		     JSR   Close1
  1835 2B3E 30 02		     BMI   GKeyError
  1836 2B40 68			     PLA 
  1837 2B41 60			     RTS
  1838 2B42			GKeyError
  1839 2B42 4C D4 2A		     JMP   GoErrorDisp
  1840 2B45			Kdriver
  1841 2B45 4B 3A 9B		     .BY "K:",$9B
  1842 2B48			DiscChangeCheck
  1843 2B48 A0 80		     LDY  #<DirMapSectorBuff
  1844 2B4A A2 2D		     LDX  #>DirMapSectorBuff
  1845 2B4C 20 F6 29		     JSR   ReadFirstSect
  1846 2B4F A2 7F		     LDX  #$7F
  1847 2B51			label98
  1848 2B51 BD 00 2D		     LDA   FirstSectorBuff,X
  1849 2B54 DD 80 2D		     CMP   DirMapSectorBuff,X
  1850 2B57 D0 05		     BNE   ChangedD
  1851 2B59 CA			     DEX 
  1852 2B5A 10 F5		     BPL   label98
  1853 2B5C A9 00		     LDA  #$00
  1854 2B5E			ChangedD
  1855 2B5E 60			     RTS
  1856 				     ; obsluga gwiazdki
  1857 					 ; w komorkach $D4 $D5 jest adres linii z pliku MSDOS.DAT zaczynajacej sie od *
  1858 					 ; w Y jest ) - X moze lepiej nie ruszac :)
  1859 2B5F			Asteriks
  1860 2B5F A0 0B		     LDY #11  ; pierwszy HEX za nazwa pliku (czyli pierwsze znaki dlugiej nazwy)
  1861 2B61 20 7D 2B			 JSR GetHexNumber
  1862 2B64 8D C5 02			 STA COLPF1S   ; literki
  1863 2B67 C8			     INY
  1864 2B68 20 7D 2B			 JSR GetHexNumber
  1865 2B6B 8D C6 02			 STA COLPF2S   ; tlo
  1866 2B6E C8				 INY
  1867 2B6F 20 7D 2B			 JSR GetHexNumber
  1868 2B72 8D C8 02			 STA COLBAKS   ; ramka
  1869 2B75 C8				 INY
  1870 2B76 20 7D 2B			 JSR GetHexNumber
  1871 2B79 8D 26 21			 STA FolderTurbo  ; znacznik turbo (00 bez turbo , 01 tak jak bylo)
  1872 2B7C 60				 RTS
  1873 					 ; pobiera z pod adresu wskazanago przez ($D4),Y dwa kolejne znaki liczby HEX
  1874 					 ; i zamienia na bajt w A
  1875 2B7D			GetHexNumber
  1876 2B7D 20 8D 2B			 JSR GetHEX4bits
  1877 2B80 0A				 ASL
  1878 2B81 0A				 ASL
  1879 2B82 0A				 ASL
  1880 2B83 0A				 ASL
  1881 2B84 85 E4			 STA TempZP ; zmienna potrzebna tylko przy jakims chwilowym obliczeniu, wiec tu sie przyda.
  1882 2B86 C8				 INY
  1883 2B87 20 8D 2B			 JSR GetHEX4bits
  1884 2B8A 05 E4		     ORA TempZP
  1885 2B8C 60				 RTS
  1886 2B8D			GetHEX4bits	 
  1887 2B8D B1 D4			 LDA ($D4),Y
  1888 2B8F 38				 SEC
  1889 2B90 E9 30			 SBC #'0'
  1890 2B92 C9 0A			 CMP #$0A ; sprawdzmy czy cyfra
  1891 2B94 90 02			 BCC IsNumber
  1892 2B96 E9 07			 SBC #7   ; Carry jest ustawiony, a miedzy 9 i A jest jeszcze 7 znakow
  1893 2B98			IsNumber
  1894 2B98 60			     RTS
  1895 					 ; Ustawia numer satcji wg A
  1896 2B99			SeTDriveNR
  1897 2B99 C9 09			 CMP #$09
  1898 2B9B B0 0F			 BCS SetDriveLetter  ; jesli wieksze lub rowne od 9 to litera zamiast cyfry
  1899 2B9D 20 BB 2B			 JSR SeTblokDanychDrive
  1900 2BA0 18			     CLC
  1901 2BA1 69 B0		     ADC #'0'+$80   ; dodajemy do kodu cyfry 0
  1902 2BA3 8D D5 22			 STA DriveDisp1
  1903 2BA6 A9 C4			 LDA #'D'+$80    ; literka D przed numerem napedu
  1904 2BA8 8D D4 22			 STA DriveDisp1-1
  1905 2BAB 60			     RTS
  1906 2BAC			SeTDriveLetter
  1907 2BAC 20 BB 2B			 JSR SeTblokDanychDrive
  1908 2BAF 18			     CLC
  1909 2BB0 69 C0		     ADC #'A'+$7F   ; $7f bo to $80 - 1 , a kod litery A trzeba zmniejszyc o 1 i dodac numer napedu
  1910 2BB2 8D D5 22			 STA DriveDisp1
  1911 2BB5 A9 A0			 LDA #' '+$80    ; literka D przed numerem napedu - tutaj spacja
  1912 2BB7 8D D4 22			 STA DriveDisp1-1
  1913 2BBA 60			     RTS
  1914 2BBB			SeTblokDanychDrive
  1915 2BBB 8D 9B 20		     STA .adr loader.blokDanychIO_Loader+1	; przed przepisaniem
  1916 2BBE 8D 3B 2A		     STA blokDanychIO+1
  1917 2BC1 8D BD 28		     STA blokDanychIO_GetUSSpeed+1
  1918 2BC4 8D EB 29			 STA blokDanychIO_PERCOM+1
  1919 2BC7 60			     RTS
  1920 				; wyswietlenie na czystm ekranie info zaraz przed rozpoczeciem ladowania pliku	 
  1921 2BC8			MEMLOprint
  1922 2BC8 AD E7 02		     LDA MEMLO
  1923 2BCB 48			     PHA 
  1924 2BCC 4A			     LSR 
  1925 2BCD 4A			     LSR 
  1926 2BCE 4A			     LSR
  1927 2BCF 4A			     LSR
  1928 2BD0 20 28 21		     JSR   bin2AsciiHex 
  1929 2BD3 8D 01 2C		     STA   MEMLOvalue+2
  1930 2BD6 68			     PLA
  1931 2BD7 20 28 21		     JSR   bin2AsciiHex 
  1932 2BDA 8D 02 2C		     STA   MEMLOvalue+3
  1933 2BDD AD E8 02		     LDA MEMLO+1
  1934 2BE0 48			     PHA 
  1935 2BE1 4A			     LSR 
  1936 2BE2 4A			     LSR 
  1937 2BE3 4A			     LSR
  1938 2BE4 4A			     LSR
  1939 2BE5 20 28 21		     JSR   bin2AsciiHex 
  1940 2BE8 8D FF 2B		     STA   MEMLOvalue
  1941 2BEB 68			     PLA
  1942 2BEC 20 28 21		     JSR   bin2AsciiHex 
  1943 2BEF 8D 00 2C		     STA   MEMLOvalue+1
  1944 2BF2 20 47 2A		     JSR PrintXY
  1945 2BF5 1C 17		     .BY 28,23
  1946 2BF7 4D 45 4D 4C 4F 3A +      .BY "MEMLO: $"
  1947 2BFF			MEMLOvalue
  1948 2BFF 30 30 30 30			 .BY "0000"
  1949 2C03 00			     .BY $00	 
  1950 2C04 60				 RTS
  1951 					 
  1952 				; Tablica adresow wszystkich rozkazow skokow w procedurze Turbo
  1953
  1954 2C05			xjsrTableL
  1955 2C05 EB FF 05			.BY <[xjsr1+1],<[xjsr2+1],<[xjsr3+1]
  1956 2C08 0B 10			.BY <[xjsr4+1],<[xjsr5+1]
  1957 2C0A 1C 26 32			.BY <[xjsr6+1],<[xjsr7+1],<[xjsr8+1]
  1958 2C0D 37 3F			.BY <[xjsr9+1],<[xjsrA+1]
  1959 2C0F			xjsrTableH
  1960 2C0F 27 27 28			.BY >[xjsr1+1],>[xjsr2+1],>[xjsr3+1]
  1961 2C12 28 28			.BY >[xjsr4+1],>[xjsr5+1]
  1962 2C14 28 28 28			.BY >[xjsr6+1],>[xjsr7+1],>[xjsr8+1]
  1963 2C17 28 28			.BY >[xjsr9+1],>[xjsrA+1]
  1964 				; miejsce na wyliczony offset o jaki przesuwamy procedure
  1965 2C19			HappyOffset
  1966 2C19 00 00		    .WO $0000
  1967 				; kody gestosci do wyswietlenia na ekranie - takie poziome kreski od chudej do grubej :)
  1968 2C1B			DensityCodes
  1969 2C1B F3 E4 F1			.by +$80,"sdq"
  1970 					;.by "SDQ"
  1971 				    ;.by $0e,$15,$a0
  1972 2C1E			ONtext
  1973 2C1E CF CE A0		    .BY +$80,"ON "
  1974 2C21			OFFtext
  1975 2C21 CF C6 C6		    .BY +$80,"OFF"
  1976 				; miejsce na przechowanie stanu urzadzen PBI (przez reset)
  1977 2C24			PDVMASKtemp
  1978 2C24 00				.BY $00
  1979 				; miejsce na blok PERCOM
  1980 2C25			PERCOMdata
  1981 				; miejsce na tablice trzymajaca numery pierwszych sektorow map bitoeych plikow aktualnie wyswietlanych na liscie
  1982 = 2C31			FirstSectorsTable=*+12 ; omijamy 12b na percom
  1983 				     ; zostawiamy $30 bajtow wolnego
  1984 					 
  1985 = 2D00			FirstSectorBuff=[[>[*+$2f+12]]+1]*$100 ; ($80 bajtow) ustawienie na granicy strony ale po ominieciu $30 i 12 bajtow
  1986 = 2D00			ProgramEnd=FirstSectorBuff
  1987 = 2D80			DirMapSectorBuff=FirstSectorBuff+$80 ; tutaj aktualny sektor mapy sektorow katalogu
  1988 = 2F80			DirSectorBuff=FirstSectorBuff+$280 ; tutaj sektor katalogu
  1989 2C25			FirstRun
  1990 				; odnotowujemy stan Shift z Bootowania
  1991 2C25 AD 0F D2		     LDA   SKSTAT 
  1992 2C28 29 08			 and   #$08
  1993 2C2A D0 03		     BNE   NoSHIFTboot  
  1994 2C2C 8D 25 21		     STA   BootShift   ; w A jest 0 wiec nie trzeba LDA #0
  1995 2C2F			NoSHIFTboot
  1996 				;  Sprawdzamy czy jest basic i ustawiamy status na ekranie
  1997 2C2F AD 01 D3		     LDA PORTB
  1998 2C32 29 02			 AND #$02
  1999 2C34 D0 0B			 BNE BrakBasica
  2000 					 ; jest Basic
  2001 2C36 A0 02			 LDY #$2
  2002 2C38			BASstatprint
  2003 2C38 B9 1E 2C			 LDA ONtext,y
  2004 2C3B 99 F0 22			 STA BASstatus,y
  2005 2C3E 88				 DEY
  2006 2C3F 10 F7			 bpl BASstatprint
  2007 2C41			BrakBasica	 
  2008 				;  Sprawdzamy istnienie QMEGa
  2009 2C41 A0 06		     ldy #$06  ; bo 6 znaków w ROMie testujemy
  2010 2C43			testQMEGloop
  2011 2C43 B9 01 C0			 LDA $C001,y
  2012 2C46 D9 76 2C			 CMP QMEGstring,y
  2013 2C49 D0 13			 bne brakQMEGa
  2014 2C4B 88				 dey
  2015 2C4C 10 F5			 bpl testQMEGloop
  2016 					 ; jest QMEG 
  2017 2C4E A9 00			 LDA #0
  2018 2C50 8D 23 21			 STA QMEG
  2019 2C53 A0 02			 LDY #$2
  2020 2C55			Qstatprint
  2021 2C55 B9 1E 2C			 LDA ONtext,y
  2022 2C58 99 E8 22			 STA QMEGstatus,y
  2023 2C5B 88				 DEY
  2024 2C5C 10 F7			 bpl Qstatprint
  2025 2C5E			brakQMEGa
  2026 				     ; kombinacja z dodaniem identyfikatara i odjeciem 1 - bo tak dziwnie OS robi
  2027 2C5E AD 00 03		     LDA DDEVIC
  2028 2C61 18			     clc	 
  2029 2C62 6D 01 03			 ADC DUNIT
  2030 2C65 38			     sec
  2031 2C66 E9 01		     SBC #$01
  2032 2C68 29 0F		     AND #$0F	 ; zapamietanie numeru urzadzenia
  2033 2C6A 8D 24 21			 STA BootDrive
  2034 2C6D 20 99 2B		     JSR SeTDriveNR
  2035 2C70 20 37 21			 JSR EditorOpen
  2036 2C73 4C 65 21		     JMP mainprog
  2037 2C76			QMEGstring
  2038 2C76 51 4D 45 47 2D 4F + 	.BY "QMEG-OS",0
  2039 2C7E 48 53 20 70 72 6F + 	.BY "HS procedures for Happy/US-Doubler, big sectors loader and compressed file map by Pecus & Pirx 2010-05-26"
  2040 					;.OPT List
  2041 					
  2042
  2043 = 0080			MAPCOUNTER
  2043 = 0082			COMPRESSEDMAPCOUNTER
  2043 = 0084			MAPCOUNTERMEM
  2043 = 0086			PREVFILESECTOR
  2043 = 0088			MAPPOSITIONMEM
  2043 = 008A			SECTOROFFSET
  2043 = 008C			SECTORSCOUNTER
  2043 				     org $02e0
  2044 02E0-02E1> 99 26		     .WO LoaderGo
  2045 				    ; .WO START 
  2046 					; na koniec pliku dwa bajty $00 bez naglowka (dla bootloadera)
  2047 				;    OPT h-
  2048 				;	org $0000
  2049 				;	.WO $0000
  2050 					
